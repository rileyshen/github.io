<!DOCTYPE html>
<html  dir="ltr" lang="en" data-theme=""><head>
    <title> Riley Shen | about fast slow points 1 </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.83.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description"
        content="java inteview algorithm">
    <meta name="google-site-verification" content="Nac1UrFTdr1E1F48JLe7XQhIbKn2_WtF4VnJI8KOtew" />
    

    
    
    
    <link rel="stylesheet" href="/css/main.min.a7c9793b97840076bef76d2743ee1c90b13bd21c18674076a0cccd5dd54c723b.css" integrity="sha256-p8l5O5eEAHa&#43;920nQ&#43;4ckLE70hwYZ0B2oMzNXdVMcjs="
        crossorigin="anonymous" type="text/css">
    
    
    <link rel="stylesheet" href="/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css"
        integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS&#43;yuWSR4=" crossorigin="anonymous" type="text/css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
        integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
        crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">

    <link rel="canonical" href="/post/fastslow1/">

    <link rel="preconnect" href="https://fonts.gstatic.com">



    
    
    
    
    <script type="text/javascript" src="/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js"
        integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ=" crossorigin="anonymous"></script>


    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://rileyshen.github.io/images/site-feature-image.png"/>

<meta name="twitter:title" content="about fast slow points 1"/>
<meta name="twitter:description" content="java inteview algorithm"/>


    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,300;0,400;0,500;0,600;0,700;1,500;1,600;1,700&display=swap"
        rel="stylesheet">

</head><body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="/images/profileS.jpg" alt="profile picture">
            <h3 title=""><a href="/">I&#39;m Riley Shen</a></h3>
            <div class="description">
                <p><br>Riley likes to push her limits <br>and always keep learning new things. <br>She shares her weekly learnings <br>because "if you can't explain it simply,<br>it means you didn't understand it well enough".<br></p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="mailto:ripple.shen31@gmail.com" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://github.com/rileyshen" rel="me" aria-label="GitHub">
                    <i class="fab fa-github fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy;  Riley Shen 2022 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/post/"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/about/"
                        
                   title="">About Me</a></li>
        
            
            <li><a 
                   href="/contact/"
                        
                   title="">Contact</a></li>
        
        
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
<div class="post  animated fadeInDown ">
    <div class="post-content">
        
        <div class="post-title">
            <h2>about fast slow points 1</h2>
            
            <div class="info">
                <em class="fas fa-calendar-day"></em>
                <span class="date">
                    Wed, Sep 1, 2021
                    </span>
                <em class="fas fa-stopwatch"></em>
                <span class="reading-time">16-minute read</span>
            </div>
            
        </div>

        <p>my fast slow point leet code list <a href="https://leetcode.com/list?selectedList=9s3nawd5"  target="_blank" >leetcode</a></p>
<!-- more -->
<!-- TOC -->
<ul>
<li><a href="#linked-list-cycle-141" >Linked List Cycle 141</a></li>
<li><a href="#linked-list-cycle-ii-142" >Linked List Cycle II 142</a></li>
<li><a href="#happy-number-202" >Happy Number 202</a></li>
<li><a href="#reorder-list-143" >Reorder List 143</a></li>
<li><a href="#remove-duplicates-from-sorted-array-26" >Remove Duplicates from Sorted Array 26</a></li>
<li><a href="#find-the-duplicate-number-287" >Find the Duplicate Number 287</a></li>
<li><a href="#maximum-twin-sum-of-a-linked-li" >Maximum Twin Sum of a Linked Li</a></li>
<li><a href="#delete-the-middle-node-of-a-linked-lis" >Delete the Middle Node of a Linked Lis</a></li>
<li><a href="#convert-sorted-list-to-binary-search-tree-109" >Convert Sorted List to Binary Search Tree 109</a></li>
<li><a href="#car-fleet-ii-1776" >Car Fleet II 1776</a></li>
</ul>
<!-- /TOC -->
<h2 id="linked-list-cycle-141">Linked List Cycle 141</h2>
<p><a id="markdown-linked-list-cycle-141" name="linked-list-cycle-141"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given head, the head of a linked list, determine <span class="k">if</span> the linked list has a cycle in it.

There is a cycle in a linked list <span class="k">if</span> there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail<span class="err">&#39;</span>s next pointer is connected to. Note that pos is not passed as a parameter.

Return <span class="nb">true</span> <span class="k">if</span> there is a cycle in the linked list. Otherwise, <span class="k">return</span> false.

 
Input: <span class="nv">head</span> <span class="o">=</span> <span class="o">[</span>3,2,0,-4<span class="o">]</span>, <span class="nv">pos</span> <span class="o">=</span> <span class="m">1</span>
Output: <span class="nb">true</span>
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node <span class="o">(</span>0-indexed<span class="o">)</span>.
</code></pre></div><p><strong>wrong answer, fast, slow at the head position</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    
    <span class="o">}</span>
</code></pre></div><p><strong>不用去判断 corner case， 都包含了</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><h2 id="linked-list-cycle-ii-142">Linked List Cycle II 142</h2>
<p><a id="markdown-linked-list-cycle-ii-142" name="linked-list-cycle-ii-142"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given the head of a linked list, <span class="k">return</span> the node where the cycle begins. If there is no cycle, <span class="k">return</span> null.

There is a cycle in a linked list <span class="k">if</span> there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail<span class="err">&#39;</span>s next pointer is connected to <span class="o">(</span>0-indexed<span class="o">)</span>. It is -1 <span class="k">if</span> there is no cycle. Note that pos is not passed as a parameter.

Do not modify the linked list.

Input: <span class="nv">head</span> <span class="o">=</span> <span class="o">[</span>3,2,0,-4<span class="o">]</span>, <span class="nv">pos</span> <span class="o">=</span> <span class="m">1</span>
Output: tail connects to node index <span class="m">1</span>
Explanation: There is a cycle in the linked list, where tail connects to the second node.
</code></pre></div><figure><img src="/images/fs1.png"
         alt="image"/><figcaption>
            <h4>fast slow points</h4>
        </figcaption>
</figure>

<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    
        <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        
            <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="n">slow</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
        <span class="o">}</span>  
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="happy-number-202">Happy Number 202</h2>
<p><a id="markdown-happy-number-202" name="happy-number-202"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Write an algorithm to determine <span class="k">if</span> a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process <span class="k">until</span> the number equals <span class="m">1</span> <span class="o">(</span>where it will stay<span class="o">)</span>, or it loops endlessly in a cycle which does not include 1.
Those numbers <span class="k">for</span> which this process ends in <span class="m">1</span> are happy.
Return <span class="nb">true</span> <span class="k">if</span> n is a happy number, and <span class="nb">false</span> <span class="k">if</span> not.

 

Example 1:

Input: <span class="nv">n</span> <span class="o">=</span> <span class="m">19</span>
Output: <span class="nb">true</span>
Explanation:
<span class="m">12</span> + <span class="nv">92</span> <span class="o">=</span> <span class="m">82</span>
<span class="m">82</span> + <span class="nv">22</span> <span class="o">=</span> <span class="m">68</span>
<span class="m">62</span> + <span class="nv">82</span> <span class="o">=</span> <span class="m">100</span>
<span class="m">12</span> + <span class="m">02</span> + <span class="nv">02</span> <span class="o">=</span> <span class="m">1</span>
</code></pre></div><p>statement that if a number ain&rsquo;t happy then it will lead to a <strong>cycle</strong> &hellip; and whenever you hear the word cycle the first thing you should remember is &ldquo;Floyd&rsquo;s cycle-finding algorithm&rdquo; also known as &ldquo;Tortoise and the Hare algorithm&rdquo;</p>
<p><strong>快慢指针</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHappy</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">n</span><span class="o">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// slow , fast
</span><span class="c1"></span>        
        <span class="k">do</span><span class="o">{</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">compute</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="c1">// slow computes only once
</span><span class="c1"></span>            <span class="n">f</span> <span class="o">=</span> <span class="n">compute</span><span class="o">(</span><span class="n">compute</span><span class="o">(</span><span class="n">f</span><span class="o">));</span> <span class="c1">// fast computes 2 times
</span><span class="c1"></span>            
            <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span><span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// if we found 1 then happy indeed !!!
</span><span class="c1"></span>        <span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">f</span><span class="o">);</span> <span class="c1">// else at some point they will meet in the cycle
</span><span class="c1"></span>        
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// it&#39;s a cycle , not happy at all !!!
</span><span class="c1"></span>          
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compute</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">0</span><span class="o">){</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="o">(</span><span class="n">n</span><span class="o">%</span><span class="n">10</span><span class="o">)*(</span><span class="n">n</span><span class="o">%</span><span class="n">10</span><span class="o">);</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">10</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><h2 id="reorder-list-143">Reorder List 143</h2>
<p><a id="markdown-reorder-list-143" name="reorder-list-143"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given the head of a singly linked-list. The list can be represented as:

L0 → L1 → … → Ln - <span class="m">1</span> → Ln
Reorder the list to be on the following form:

L0 → Ln → L1 → Ln - <span class="m">1</span> → L2 → Ln - <span class="m">2</span> → …
You may not modify the values in the list<span class="err">&#39;</span>s nodes. Only nodes themselves may be changed.

Input: <span class="nv">head</span> <span class="o">=</span> <span class="o">[</span>1,2,3,4<span class="o">]</span>
Output: <span class="o">[</span>1,4,2,3<span class="o">]</span>

</code></pre></div><p><strong>split into two halves, merge</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reorderList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ListNode</span> <span class="n">midNode</span> <span class="o">=</span> <span class="n">midNode</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        
       
       
        
        <span class="n">ListNode</span> <span class="n">newNode</span> <span class="o">=</span> <span class="n">reverse</span><span class="o">(</span><span class="n">midNode</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
        <span class="n">midNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        
        
        <span class="n">ListNode</span> <span class="n">cur1</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">cur2</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="k">while</span> <span class="o">(</span><span class="n">cur1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">cur</span> <span class="o">=</span> <span class="n">cur1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur2</span><span class="o">;</span>
            
            <span class="n">cur1</span> <span class="o">=</span> <span class="n">cur2</span><span class="o">;</span>
            <span class="n">cur2</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="o">}</span>
        
       
    <span class="o">}</span>
    
   <span class="n">ListNode</span> <span class="nf">midNode</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">){</span>
         <span class="n">ListNode</span> <span class="n">fast</span> <span class="o">=</span>  <span class="n">head</span><span class="o">,</span> <span class="n">slow</span>  <span class="o">=</span>  <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">fast</span> <span class="o">=</span>  <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span>  <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
   <span class="o">}</span>
    
    <span class="n">ListNode</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ListNode</span> <span class="n">curr</span> <span class="o">=</span>  <span class="n">head</span><span class="o">,</span> <span class="n">prev</span><span class="o">=</span>  <span class="kc">null</span><span class="o">,</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">curr</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">next</span>  <span class="o">=</span>  <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span>  <span class="n">prev</span> <span class="o">;</span>
            <span class="n">prev</span> <span class="o">=</span>  <span class="n">curr</span><span class="o">;</span>
            <span class="n">curr</span>  <span class="o">=</span>  <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><p>TIME COMPLEXITY : O(n)</p>
<p>SPACE COMPLEXITY : O(1)</p>
<p><strong>Single traversal</strong>
<a href="https://leetcode.com/problems/reorder-list/discuss/1640806/Java-or-2-Approach-or-2-Pointer-Approach"  target="_blank" >leetcode solution</a></p>
<figure><img src="/images/fs2.png"
         alt="image"/><figcaption>
            <h4>fast slow points</h4>
        </figcaption>
</figure>

<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6
left                     right</p>
<p>1 -&gt; 6 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 
left           right</p>
<p><strong>recursion call</strong></p>
<p><strong>错误的回溯</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reorderList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">reorder</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
<span class="o">}</span>
    <span class="kt">void</span> <span class="nf">reorder</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">cur</span><span class="o">,</span> <span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">reorder</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
        
        
        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
       
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>1 -&gt; 2 -&gt; 3 -&gt; 4 
cur             head
next
cur.next = 4</p>
<p><strong>新循环 cur 又是 1</strong></p>
<p><strong>这跟传参有关，所以每次都是从 1 开始， 但是弄成全局模式，就是下面讨巧的方法就可以</strong></p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 
cur       head</p>
<p><strong>所以报错说有环，因为 cur 这个值无法储存</strong></p>
<p><strong>用一个 ListNode[] 储存</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">reorderList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">ListNode</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
        <span class="n">cur</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">reorder</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">reorder</span><span class="o">(</span><span class="n">ListNode</span><span class="o">[]</span> <span class="n">cur</span><span class="o">,</span> <span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">reorder</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span>  <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>


        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">next</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cur</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><strong>非常讨巧的方法</strong>
<a href="https://leetcode.com/problems/reorder-list/discuss/1059115/JAVA-One-Pass-Recursive-Solution-With-Animation-Explanation"  target="_blank" >leetcode</a></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">  <span class="kd">private</span> <span class="n">ListNode</span> <span class="n">temp</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isStop</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reorderList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">isStop</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">reorder</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">reorder</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="n">reorder</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">isStop</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">isStop</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><h2 id="remove-duplicates-from-sorted-array-26">Remove Duplicates from Sorted Array 26</h2>
<p><a id="markdown-remove-duplicates-from-sorted-array-26" name="remove-duplicates-from-sorted-array-26"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, <span class="k">if</span> there are k elements after removing the duplicates, <span class="k">then</span> the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space <span class="k">for</span> another array. You must <span class="k">do</span> this by modifying the input array in-place with O<span class="o">(</span>1<span class="o">)</span> extra memory.

Custom Judge:

The judge will <span class="nb">test</span> your solution with the following code:

int<span class="o">[]</span> <span class="nv">nums</span> <span class="o">=</span> <span class="o">[</span>...<span class="o">]</span><span class="p">;</span> // Input array
int<span class="o">[]</span> <span class="nv">expectedNums</span> <span class="o">=</span> <span class="o">[</span>...<span class="o">]</span><span class="p">;</span> // The expected answer with correct length
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
       <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">nums</span><span class="o">[++</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="n">j</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><h2 id="find-the-duplicate-number-287">Find the Duplicate Number 287</h2>
<p><a id="markdown-find-the-duplicate-number-287" name="find-the-duplicate-number-287"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an array of integers nums containing n + <span class="m">1</span> integers where each integer is in the range <span class="o">[</span>1, n<span class="o">]</span> inclusive.

There is only one repeated number in nums, <span class="k">return</span> this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.

 

Example 1:

Input: <span class="nv">nums</span> <span class="o">=</span> <span class="o">[</span>1,3,4,2,2<span class="o">]</span>
Output: <span class="m">2</span>
</code></pre></div><p><strong>其核心思想快慢指针在之前的题目 Linked List Cycle II 中就有应用，这里应用的更加巧妙一些，由于题目限定了区间 [1,n]，所以可以巧妙的利用坐标和数值之间相互转换，而由于重复数字的存在，那么一定会形成环，用快慢指针可以找到环并确定环的起始位置</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span><span class="n">0</span> <span class="o">)</span>
                <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">slow</span><span class="o">=</span><span class="n">0</span><span class="o">,</span> <span class="n">fast</span><span class="o">=</span><span class="n">0</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">];</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">]];</span>
            <span class="k">while</span><span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">])</span>
                    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
                <span class="n">slow</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">];</span>
                <span class="n">fast</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">]];</span>
            <span class="o">}</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">])</span>
                    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
                <span class="n">slow</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">];</span>
                <span class="n">fast</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
    <span class="o">}</span>


</code></pre></div><p><strong>Bit Manipulation，  对于 int 32 位，统计 nums[0..n-1]在第 k 位的 1 的总数 b，与 0..n-1 在第 k 位的 1 的总数 a 如果 b &gt; a，说明第 k 位存在重复（多了 1）</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">findDuplicate</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">32</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="o">(</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="o">);</span>     <span class="c1">// 1 右移 k 位
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span><span class="o">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">++</span><span class="n">a</span><span class="o">;</span>
            <span class="k">if</span><span class="o">((</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">++</span><span class="n">b</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">bit</span><span class="o">;</span>   <span class="c1">// 重复数的k位
</span><span class="c1"></span>    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div><h2 id="maximum-twin-sum-of-a-linked-l">Maximum Twin Sum of a Linked L</h2>
<p><a id="markdown-maximum-twin-sum-of-a-linked-li" name="maximum-twin-sum-of-a-linked-li"></a>i</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">In a linked list of size n, where n is even, the ith node <span class="o">(</span>0-indexed<span class="o">)</span> of the linked list is known as the twin of the <span class="o">(</span>n-1-i<span class="o">)</span>th node, <span class="k">if</span> <span class="m">0</span> &lt;<span class="o">=</span> i &lt;<span class="o">=</span> <span class="o">(</span>n / 2<span class="o">)</span> - 1.

For example, <span class="k">if</span> <span class="nv">n</span> <span class="o">=</span> 4, <span class="k">then</span> node <span class="m">0</span> is the twin of node 3, and node <span class="m">1</span> is the twin of node 2. These are the only nodes with twins <span class="k">for</span> <span class="nv">n</span> <span class="o">=</span> 4.
The twin sum is defined as the sum of a node and its twin.

Given the head of a linked list with even length, <span class="k">return</span> the maximum twin sum of the linked list.

Input: <span class="nv">head</span> <span class="o">=</span> <span class="o">[</span>5,4,2,1<span class="o">]</span>
Output: <span class="m">6</span>
Explanation:
Nodes <span class="m">0</span> and <span class="m">1</span> are the twins of nodes <span class="m">3</span> and 2, respectively. All have twin <span class="nv">sum</span> <span class="o">=</span> 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6. 
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pairSum</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
       
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">reverse</span><span class="o">(</span><span class="n">slow</span><span class="o">);</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">slow</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">fast</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">ListNode</span> <span class="n">previous</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">previous</span><span class="o">;</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">previous</span><span class="o">;</span>
    <span class="o">}</span>
    

</code></pre></div><p><strong>又是回溯，利用 head 到了尾部 null 的时候，倒退的原理</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pairSum</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
 <span class="n">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pairSum</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
      <span class="n">maxSum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">computer</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">computer</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">computer</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
        <span class="n">maxSum</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">head</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">prev</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><h2 id="delete-the-middle-node-of-a-linked-li">Delete the Middle Node of a Linked Li</h2>
<p><a id="markdown-delete-the-middle-node-of-a-linked-lis" name="delete-the-middle-node-of-a-linked-lis"></a>s</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given the head of a linked list. Delete the middle node, and <span class="k">return</span> the head of the modified linked list.

The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.

For <span class="nv">n</span> <span class="o">=</span> 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.

Input: <span class="nv">head</span> <span class="o">=</span> <span class="o">[</span>1,3,4,7,1,2,6<span class="o">]</span>
Output: <span class="o">[</span>1,3,4,1,2,6<span class="o">]</span>
Explanation:
The above figure represents the given linked list. The indices of the nodes are written below.
Since <span class="nv">n</span> <span class="o">=</span> 7, node <span class="m">3</span> with value <span class="m">7</span> is the middle node, which is marked in red.
We <span class="k">return</span> the new list after removing this node.
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">deleteMiddle</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">slow</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><p><strong>dummy head</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">deleteMiddle</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">(-</span><span class="n">1</span><span class="o">),</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span> 
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>  
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> 
    <span class="o">}</span>
</code></pre></div><h2 id="convert-sorted-list-to-binary-search-tree-109">Convert Sorted List to Binary Search Tree 109</h2>
<p><a id="markdown-convert-sorted-list-to-binary-search-tree-109" name="convert-sorted-list-to-binary-search-tree-109"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Input: <span class="nv">head</span> <span class="o">=</span> <span class="o">[</span>-10,-3,0,5,9<span class="o">]</span>
Output: <span class="o">[</span>0,-3,9,-10,null,5<span class="o">]</span>
Explanation: One possible answer is <span class="o">[</span>0,-3,9,-10,null,5<span class="o">]</span>, which represents the shown height balanced BST.
</code></pre></div><p>time: O(nlong)</p>
<p>space: time: O(nlong)</p>
<p><strong>每次找中点, 想象成一条绳，提起中点作为根节点，分出左右两部分，再提起各自的中点作为根节点……分治下去，这根绳就成了 BST 的模样</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">sortedListToBST</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span><span class="k">return</span> <span class="kc">null</span><span class="o">;</span>


      <span class="n">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="k">while</span><span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">slow</span><span class="o">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="o">}</span>
      
     
      <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">slow</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
      <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">sortedListToBST</span><span class="o">(</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">sortedListToBST</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
      <span class="o">}</span>   
      <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>   

</code></pre></div><p><strong>Convert linked list to array then do PreOrder Traversal</strong></p>
<p><strong>arr[mid] as the root</strong></p>
<p><strong>(left, mid - 1) as the left sub</strong></p>
<p><strong>(mid + 1, right) as the right sub</strong></p>
<p>time: O(N)</p>
<p>space: time: O(N)</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">sortedListToBST</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
     <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
         <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="k">return</span> <span class="n">helper</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="n">TreeNode</span> <span class="nf">helper</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
     <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mid</span><span class="o">));</span>
     <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">helper</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
     <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">helper</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
     <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div><p><strong>中序遍历</strong></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(logn)</p>
<p>方法 1 每次获取数组中点：O(1)，方法 2 每次获取链表中点：O(N)，所以更慢。</p>
<p>其实直接获取链表头结点：O(1)O(1)，不如直接构建它吧！它对应 BST 最左子树的根节点。</p>
<p>于是我们先构建左子树，再构建根节点，再构建右子树。——遵循中序遍历。</p>
<p>其实，BST 的中序遍历，打印的节点值正是这个有序链表的节点值顺序。</p>
<p>如下图，维护指针 h，从头结点开始，用 h.val 构建节点，构建一个，指针后移一位。</p>
<p>求出链表结点总个数，用于每次二分求出链表的中点。</p>
<p>为什么要这么做，因为我们构建的节点值是：从小到大，我们希望在递归中处理节点的顺序和链表结点顺序一一对应</p>
<p>看看下图的递归树，感受一下二分法怎么做到的。</p>
<p>用二分后的左链，递归构建左子树，然后用 h.val 创建节点，接上创建好的左子树，再用右链构建右子树，再接上。</p>
<p>递归中会不断进行二分，直到无法划分就返回 null，即来到递归树的底部</p>
<p>h.val 创建完结点后，h 指针就后移，锁定出下一个要构建的节点值</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ListNode</span> <span class="n">head</span><span class="o">;</span>
 <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">sortedListToBST</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">this</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
     <span class="k">return</span> <span class="n">helper</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">length</span><span class="o">(</span><span class="n">head</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="n">TreeNode</span> <span class="nf">helper</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
     <span class="n">TreeNode</span> <span class="n">leftNode</span> <span class="o">=</span> <span class="n">helper</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// 先递归构建左子树
</span><span class="c1"></span>
     <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">);</span> <span class="c1">//  // 根据 h.val 构建节点
</span><span class="c1"></span>     <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">//  // h指针步进        
</span><span class="c1"></span>
     <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">leftNode</span><span class="o">;</span>
     <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">helper</span><span class="o">(</span><span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
     <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="kt">int</span> <span class="nf">length</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
     <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
          <span class="n">res</span><span class="o">++;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
 <span class="o">}</span>

</code></pre></div><h2 id="car-fleet-ii-1776">Car Fleet II 1776</h2>
<p><a id="markdown-car-fleet-ii-1776" name="car-fleet-ii-1776"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>positioni, speedi<span class="o">]</span> represents:

positioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni &lt; positioni+1.
speedi is the initial speed of the ith car in meters per second.
For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet.

Return an array answer, where answer<span class="o">[</span>i<span class="o">]</span> is the time, in seconds, at which the ith car collides with the next car, or -1 <span class="k">if</span> the car does not collide with the next car. Answers within 10-5 of the actual answers are accepted.

Example 1:

Input: <span class="nv">cars</span> <span class="o">=</span> <span class="o">[[</span>1,2<span class="o">]</span>,<span class="o">[</span>2,1<span class="o">]</span>,<span class="o">[</span>4,3<span class="o">]</span>,<span class="o">[</span>7,2<span class="o">]]</span>
Output: <span class="o">[</span>1.00000,-1.00000,3.00000,-1.00000<span class="o">]</span>
Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed <span class="m">1</span> m/s. After exactly <span class="m">3</span> seconds, the third car will collide with the fourth car, and form a car fleet with speed <span class="m">2</span> m/s.
</code></pre></div><p><strong>Imagine a,b,c on the road, if the a catches b later than b catched c, then a won&rsquo;t catch b but b+c</strong></p>
<p>Complexity</p>
<p>Time O(n)</p>
<p>Space O(n)</p>
<p><strong>a, b, c, d, 如果 c 追上了 d， b 就有 3 个情况： 能追上； 追不上 c， 但是追上 d； c, d 都追不上</strong></p>
<p>此处的详细说明：</p>
<ol>
<li>如果当前车的车速 &lt;= 栈顶车的车速，则当前车永远无法追上栈顶车，因此总是可以 pop 出栈顶车；</li>
<li>否则，如果当前车的车速 &gt; 栈顶车：
2.1 如果栈顶车的追上更右侧车辆的时间为 -1 (永远追不上)，则不能 pop 出;
2.2 否则，则判断在 “理想状态(即栈顶车不会追上更右侧车)”下 ，当前车的追上栈顶车的时间 T
(也就是下面代码里的式子)，如果 T &gt; res<a href="%e5%8d%b3%e6%a0%88%e9%a1%b6%e8%bd%a6%e7%9a%84%e5%ae%9e%e9%99%85%e8%bf%bd%e5%8f%8a%e6%97%b6%e9%97%b4" >st.top()</a>，
说明不能在右侧车追上更右侧车之前追上，应当 pop；否则能在碰撞前追上。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">double</span><span class="o">[]</span> <span class="nf">getCollisionTimes</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">cars</span><span class="o">)</span> <span class="o">{</span>
        
        
       <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">Deque</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="kt">double</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">.</span><span class="na">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">cars</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">],</span> <span class="n">s</span> <span class="o">=</span> <span class="n">cars</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">(),</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">cars</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">0</span><span class="o">],</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">cars</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
                
                <span class="cm">/** Now we have either one of situations
</span><span class="cm">                    1. c1 is slower than c2
</span><span class="cm">                    2. c1 potentially catches c2 AFTER c2 vanishes
</span><span class="cm">                    
</span><span class="cm">                    Claim: no car before c1 will vanish into c2 
</span><span class="cm">                    
</span><span class="cm">                    1. ==&gt; cars before c1 will vanish into c1 first before catching c2 
</span><span class="cm">                    2. &lt;==&gt; c2 &#34;vanishes&#34; into another car even before c1 catches it
</span><span class="cm">                
</span><span class="cm">                    
</span><span class="cm">                Either way, c2 can not be catched by c1 or cars beofre c1 ==&gt; poll it out from stack
</span><span class="cm">                
</span><span class="cm">                */</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">s2</span> <span class="o">||</span> <span class="n">1</span><span class="o">.</span><span class="na">0</span> <span class="o">*</span> <span class="o">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">s2</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peekLast</span><span class="o">(),</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">cars</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">0</span><span class="o">],</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">cars</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">.</span><span class="na">0</span> <span class="o">*</span> <span class="o">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">s2</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

</code></pre></div><p>O(N\log N)O(NlogN)</p>
<p>一个相对直观的思路是：我们按照时间大小顺序，先找出最先相遇的两辆车，再找出随后相遇的两辆车，最终找出最后相遇的两辆车。由于两辆车相遇后会「变为一辆车」，因此最多找 n-1n−1 次即可。</p>
<p>我们使用优先队列来维护这一关系。优先队列的每个元素 \textit{Node}Node 代表每次「相遇」，它具有三个属性：距离起点较近的车 \textit{low}low，距离起点较远的车 \textit{high}high，以及它们相撞所需的时间 tt。</p>
<p>初始时，最先相撞的两辆车，一定来自两辆直接相邻的车。因此，我们首先遍历 \textit{cars}cars 数组，将 n-1n−1 对相邻的车加入到优先队列当中。</p>
<p>随后，我们不断取出优先队列的头部元素 \textit{Node}Node，随后：</p>
<p>将第 \textit{Node}.\textit{low}Node.low 辆车的相遇时间设置为 \textit{Node}.\textit{t}Node.t，放入结果数组中。
将第 \textit{Node}.\textit{low}Node.low 辆车以某种形式「删除」。因为两车相遇后，由于两车的速度都变为较慢车的速度，故随后的时间里就只需要考虑第 \textit{Node}.\textit{high}Node.high 辆车。
第 \textit{Node}.\textit{low}Node.low 辆车被删除后，离第 \textit{Node}.\textit{high}Node.high 辆车后面最近的那辆车也发生了变化。因此，要找出删除后离第 \textit{Node}.\textit{high}Node.high 辆车后面最近的那辆车，并将该车与第 \textit{Node}.\textit{high}Node.high 辆车放入优先队列当中</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">id</span><span class="o">;</span> <span class="c1">// car_id
</span><span class="c1"></span>        <span class="kt">double</span> <span class="n">time</span><span class="o">;</span> <span class="c1">// the time for collision with the next car
</span><span class="c1"></span>        
        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">_id</span><span class="o">,</span> <span class="kt">double</span> <span class="n">_time</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">id</span> <span class="o">=</span> <span class="n">_id</span><span class="o">;</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">_time</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span><span class="o">[]</span> <span class="nf">getCollisionTimes</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">cars</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="n">200000</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Double</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">time</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">time</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cars</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">cars</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">][</span><span class="n">1</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// if there could be collision for i-th car and i+1-th car
</span><span class="c1"></span>                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="kt">double</span><span class="o">)(</span><span class="n">cars</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">cars</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="kt">double</span><span class="o">)(</span><span class="n">cars</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">cars</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">][</span><span class="n">1</span><span class="o">])));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="kt">double</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">.</span><span class="na">0</span><span class="o">);</span>
        <span class="n">TreeSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">&lt;&gt;();</span> <span class="c1">// used to record all alive cars
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">.</span><span class="na">id</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">.</span><span class="na">0</span><span class="o">)</span> <span class="c1">// this means such car is already processed in previous steps
</span><span class="c1"></span>                <span class="k">continue</span><span class="o">;</span>
            <span class="n">res</span><span class="o">[</span><span class="n">cur</span><span class="o">.</span><span class="na">id</span><span class="o">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">time</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ts</span><span class="o">.</span><span class="na">lower</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">id</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// if there is no previous car, no need for update
</span><span class="c1"></span>                <span class="k">continue</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="na">lower</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">id</span><span class="o">);</span> <span class="c1">// find the previous alive car
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="na">higher</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">id</span><span class="o">);</span> <span class="c1">// find the next car, since this is the next car of the previous car now
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">cars</span><span class="o">[</span><span class="n">prev</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">cars</span><span class="o">[</span><span class="n">next</span><span class="o">][</span><span class="n">1</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// update the information of previous car
</span><span class="c1"></span>                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">prev</span><span class="o">,</span> <span class="o">(</span><span class="kt">double</span><span class="o">)(</span><span class="n">cars</span><span class="o">[</span><span class="n">next</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">cars</span><span class="o">[</span><span class="n">prev</span><span class="o">][</span><span class="n">0</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="kt">double</span><span class="o">)(</span><span class="n">cars</span><span class="o">[</span><span class="n">prev</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">cars</span><span class="o">[</span><span class="n">next</span><span class="o">][</span><span class="n">1</span><span class="o">])));</span> 
            <span class="o">}</span>
            <span class="n">ts</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">id</span><span class="o">);</span> <span class="c1">// such car is dead, remove it
</span><span class="c1"></span>        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><p>😼😼😼😼</p>
<ul>
<li>😼<a href="https://rileyshen.github.io/post/2pointers1/" >2pointers1</a></li>
<li>😼<a href="https://rileyshen.github.io/post/slidewindow1/" >slidewindow1</a></li>
</ul>
<hr>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/MPnaiL</p>
<p>感谢：她们都有题库在 github 上直接有，都是大神, 都富有详细解法，对新人特别适合了解解题思路</p>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/wtcaE1/solution/jian-dan-yi-dong-javac-pythonjshua-dong-dtang/">https://leetcode-cn.com/problems/wtcaE1/solution/jian-dan-yi-dong-javac-pythonjshua-dong-dtang/</a></p>
</li>
<li>
<p>宫水三叶</p>
</li>
<li>
<p>Grandyang (<a href="https://www.cnblogs.com/grandyang/">https://www.cnblogs.com/grandyang/</a>)</p>
</li>
<li>
<p>花花酱（油管频道视频）</p>
</li>
</ul>
</div>
    <div class="post-footer">
        <div class="info">
            
            <span class="separator"><a class="tag" href="/tags/java/">java</a><a class="tag" href="/tags/java-interview/">java interview</a><a class="tag" href="/tags/algorithm/">algorithm</a><a class="tag" href="/tags/fast-slow-points/">fast slow points</a></span>
        </div>
    </div>

    
</div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js"
        integrity="sha256-g8sd1f6o1C2H0eYBoH&#43;qcwia0O&#43;cz&#43;Xa9gQSievMTkY="
        crossorigin="anonymous"></script>
<script async defer src="//latest.js"></script>
<noscript><img src="//noscript.gif" alt=""/></noscript>

</body>

</html>
