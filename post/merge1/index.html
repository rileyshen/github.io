<!DOCTYPE html>
<html  dir="ltr" lang="en" data-theme=""><head>
    <title> Riley Shen | about Merge Intervals 1 </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.83.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description"
        content="java inteview algorithm">
    <meta name="google-site-verification" content="Nac1UrFTdr1E1F48JLe7XQhIbKn2_WtF4VnJI8KOtew" />
    

    
    
    
    <link rel="stylesheet" href="/css/main.min.a7c9793b97840076bef76d2743ee1c90b13bd21c18674076a0cccd5dd54c723b.css" integrity="sha256-p8l5O5eEAHa&#43;920nQ&#43;4ckLE70hwYZ0B2oMzNXdVMcjs="
        crossorigin="anonymous" type="text/css">
    
    
    <link rel="stylesheet" href="/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css"
        integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS&#43;yuWSR4=" crossorigin="anonymous" type="text/css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
        integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
        crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">

    <link rel="canonical" href="/post/merge1/">

    <link rel="preconnect" href="https://fonts.gstatic.com">



    
    
    
    
    <script type="text/javascript" src="/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js"
        integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ=" crossorigin="anonymous"></script>


    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://rileyshen.github.io/images/site-feature-image.png"/>

<meta name="twitter:title" content="about Merge Intervals 1"/>
<meta name="twitter:description" content="java inteview algorithm"/>


    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,300;0,400;0,500;0,600;0,700;1,500;1,600;1,700&display=swap"
        rel="stylesheet">

</head><body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="/images/profileS.jpg" alt="profile picture">
            <h3 title=""><a href="/">I&#39;m Riley Shen</a></h3>
            <div class="description">
                <p><br>Riley likes to push her limits <br>and always keep learning new things. <br>She shares her weekly learnings <br>because "if you can't explain it simply,<br>it means you didn't understand it well enough".<br></p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="mailto:ripple.shen31@gmail.com" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://github.com/rileyshen" rel="me" aria-label="GitHub">
                    <i class="fab fa-github fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy;  Riley Shen 2022 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/post/"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/about/"
                        
                   title="">About Me</a></li>
        
            
            <li><a 
                   href="/contact/"
                        
                   title="">Contact</a></li>
        
        
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
<div class="post  animated fadeInDown ">
    <div class="post-content">
        
        <div class="post-title">
            <h2>about Merge Intervals 1</h2>
            
            <div class="info">
                <em class="fas fa-calendar-day"></em>
                <span class="date">
                    Wed, Sep 1, 2021
                    </span>
                <em class="fas fa-stopwatch"></em>
                <span class="reading-time">21-minute read</span>
            </div>
            
        </div>

        <!-- more -->
<p>my Merge Intervalsleet code list <a href="https://leetcode.com/list?selectedList=9471z7uh"  target="_blank" >leetcode</a></p>
<!-- TOC -->
<ul>
<li><a href="#insert-interval-57" >Insert Interval 57</a></li>
<li><a href="#employee-free-time-759" >Employee Free Time 759</a></li>
<li><a href="#merge-intervals-56" >Merge Intervals 56</a></li>
<li><a href="#the-skyline-problem-218" >The Skyline Problem 218</a></li>
<li><a href="#non-overlapping-intervals-435" >Non-overlapping Intervals 435</a></li>
<li><a href="#minimum-number-of-arrows-to-burst-balloons-452" >Minimum Number of Arrows to Burst Balloons 452</a></li>
<li><a href="#my-calendar-i-729" >My Calendar I 729</a></li>
<li><a href="#my-calendar-ii-731" >My Calendar II 731</a></li>
<li><a href="#my-calendar-iii-732" >My Calendar III 732</a></li>
<li><a href="#describe-the-painting-1943" >Describe the Painting 1943</a></li>
<li><a href="#falling-squares-699" >Falling Squares 699</a></li>
<li><a href="#task-scheduler-621" >Task Scheduler 621</a></li>
</ul>
<!-- /TOC -->
<p>区间合并模式是一个用来处理有区间重叠的很高效的技术。在设计到区间的很多问题中，通常咱们需要要么判断是否有重叠，要么合并区间，如果他们重叠的话。这个模式是这么起作用的：</p>
<p>怎么识别啥时候用合并区间模式呀？</p>
<p>当你需要产生一堆相互之间没有交集的区间的时候
当你听到重叠区间的时候
经典题目：</p>
<h2 id="insert-interval-57">Insert Interval 57</h2>
<p><a id="markdown-insert-interval-57" name="insert-interval-57"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an array of non-overlapping intervals intervals where intervals<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>starti, endi<span class="o">]</span> represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval <span class="nv">newInterval</span> <span class="o">=</span> <span class="o">[</span>start, end<span class="o">]</span> that represents the start and end of another interval.

Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals <span class="o">(</span>merge overlapping intervals <span class="k">if</span> necessary<span class="o">)</span>.

Return intervals after the insertion.

Example 1:

Input: <span class="nv">intervals</span> <span class="o">=</span> <span class="o">[[</span>1,3<span class="o">]</span>,<span class="o">[</span>6,9<span class="o">]]</span>, <span class="nv">newInterval</span> <span class="o">=</span> <span class="o">[</span>2,5<span class="o">]</span>
Output: <span class="o">[[</span>1,5<span class="o">]</span>,<span class="o">[</span>6,9<span class="o">]]</span>

</code></pre></div><p>input:[
[1, 2]
[3, 5]
[6, 7]
[8, 10]
[12, 16]
]</p>
<p>newInterval[4, 8]</p>
<p><strong>[1, 2]中 2 点结束， 早于 4 点开始, 所以 res 中添加 [1, 2]</strong></p>
<blockquote>
<p>while (i &lt; intervals.length() &amp;&amp; intervals[i][1] &lt; newInterval[0]) {
res.add(new int[]{intervals[i][0], intervals[i][1]});
}</p>
</blockquote>
<p>res:
[1， 2]
[]</p>
<p><strong>[3, 5]中 和 4 发生了 overlap， 跳出循环</strong></p>
<blockquote>
<p>while (i &lt; intervals.length() &amp;&amp; intervals[i][0] &lt;= newInterval[1]) {
newInterval[0] = Math.min(intervals[i][0], new Interval[0]); // newInterval[3, 8], [3, 8], [3, 10]
newInterval[1] = Math.max(intervals[i][1], new Interval[1]); 
i++;
}</p>
</blockquote>
<p><strong>更新完 newInterval， 加入 res</strong></p>
<p><strong>[12, 16]中 8 结束的时间小于 12 开始的时间，所以肯定没交集</strong></p>
<p>☕
推荐山景城一姐 <a href="https://www.youtube.com/watch?v=E9IYRG_WYcM"  target="_blank" >youtube</a>
:coffee：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">newInterval</span><span class="o">)</span> <span class="o">{</span>
      
        <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">newInterval</span><span class="o">[</span><span class="n">0</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">newInterval</span><span class="o">[</span><span class="n">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">newInterval</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]);</span>
            <span class="n">newInterval</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">newInterval</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]);</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newInterval</span><span class="o">);</span>
         <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        
        
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()][]);</span>
    <span class="o">}</span>


</code></pre></div><h2 id="employee-free-time-759">Employee Free Time 759</h2>
<p><a id="markdown-employee-free-time-759" name="employee-free-time-759"></a></p>
<figure><img src="/images/merge1.png"
         alt="image"/><figcaption>
            <h4>merge Intervals</h4>
        </figcaption>
</figure>

<figure><img src="/images/merge2.png"
         alt="image"/><figcaption>
            <h4>merge Intervals</h4>
        </figcaption>
</figure>

<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="nf">employeeFreeTime</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;&gt;</span> <span class="n">schedule</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        
        <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">intervals</span> <span class="o">:</span> <span class="n">schedule</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Interval</span> <span class="n">interval</span> <span class="o">:</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">interval</span><span class="o">.</span><span class="na">start</span><span class="o">,</span> <span class="n">0</span><span class="o">});</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">interval</span><span class="o">.</span><span class="na">end</span><span class="o">,</span> <span class="n">1</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="n">list</span><span class="o">.</span><span class="na">sort</span><span class="o">((</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">p1</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">?</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">p1</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">p2</span><span class="o">[</span><span class="n">0</span><span class="o">])</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">p1</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">p2</span><span class="o">[</span><span class="n">1</span><span class="o">]));</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">begin</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pair</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">--;</span>
            <span class="o">}</span>
            
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Interval</span><span class="o">(</span><span class="n">pair</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">pair</span><span class="o">[</span><span class="n">0</span><span class="o">]));</span>
                <span class="n">begin</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">begin</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">).</span><span class="na">end</span> <span class="o">=</span> <span class="n">pair</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
                <span class="n">begin</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="n">res</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Interval</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Interval</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nf">Interval</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="merge-intervals-56">Merge Intervals 56</h2>
<p><a id="markdown-merge-intervals-56" name="merge-intervals-56"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an array of intervals where intervals<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>starti, endi<span class="o">]</span>, merge all overlapping intervals, and <span class="k">return</span> an array of the non-overlapping intervals that cover all the intervals in the input.

Example 1:

Input: <span class="nv">intervals</span> <span class="o">=</span> <span class="o">[[</span>1,3<span class="o">]</span>,<span class="o">[</span>2,6<span class="o">]</span>,<span class="o">[</span>8,10<span class="o">]</span>,<span class="o">[</span>15,18<span class="o">]]</span>
Output: <span class="o">[[</span>1,6<span class="o">]</span>,<span class="o">[</span>8,10<span class="o">]</span>,<span class="o">[</span>15,18<span class="o">]]</span>
Explanation: Since intervals <span class="o">[</span>1,3<span class="o">]</span> and <span class="o">[</span>2,6<span class="o">]</span> overlaps, merge them into <span class="o">[</span>1,6<span class="o">]</span>.
Example 2:

Constraints:

<span class="m">1</span> &lt;<span class="o">=</span> intervals.length &lt;<span class="o">=</span> <span class="m">104</span>
intervals<span class="o">[</span>i<span class="o">]</span>.length <span class="o">==</span> <span class="m">2</span>
<span class="m">0</span> &lt;<span class="o">=</span> starti &lt;<span class="o">=</span> endi &lt;<span class="o">=</span> <span class="m">104</span>
</code></pre></div><p>时间复杂度 O ( n log ⁡ n ) ，空间 O ( n )</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">intervals</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span><span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">]);</span>
        
    
        
        
        <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">0</span><span class="o">]);</span> <span class="c1">// [1, 3] -&gt;
</span><span class="c1"></span>        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// start from 1
</span><span class="c1"></span>            <span class="kt">int</span><span class="o">[]</span> <span class="n">end</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// end = [1, 3] vs intervals[1][0]
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">end</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// 3 &gt; 2
</span><span class="c1"></span>                <span class="n">end</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">end</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]);</span> <span class="c1">// end = [1, 6]
</span><span class="c1"></span>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>  
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()][</span><span class="n">2</span><span class="o">]);</span>    
    <span class="o">}</span>
</code></pre></div><h2 id="the-skyline-problem-218">The Skyline Problem 218</h2>
<p><a id="markdown-the-skyline-problem-218" name="the-skyline-problem-218"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">A city<span class="s1">&#39;s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.
</span><span class="s1">
</span><span class="s1">The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:
</span><span class="s1">
</span><span class="s1">lefti is the x coordinate of the left edge of the ith building.
</span><span class="s1">righti is the x coordinate of the right edge of the ith building.
</span><span class="s1">heighti is the height of the ith building.
</span><span class="s1">You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.
</span><span class="s1">
</span><span class="s1">The skyline should be represented as a list of &#34;key points&#34; sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline&#39;</span>s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline<span class="err">&#39;</span>s contour.

Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <span class="o">[</span>...,<span class="o">[</span><span class="m">2</span> 3<span class="o">]</span>,<span class="o">[</span><span class="m">4</span> 5<span class="o">]</span>,<span class="o">[</span><span class="m">7</span> 5<span class="o">]</span>,<span class="o">[</span><span class="m">11</span> 5<span class="o">]</span>,<span class="o">[</span><span class="m">12</span> 7<span class="o">]</span>,...<span class="o">]</span> is not acceptable<span class="p">;</span> the three lines of height <span class="m">5</span> should be merged into one in the final output as such: <span class="o">[</span>...,<span class="o">[</span><span class="m">2</span> 3<span class="o">]</span>,<span class="o">[</span><span class="m">4</span> 5<span class="o">]</span>,<span class="o">[</span><span class="m">12</span> 7<span class="o">]</span>,...<span class="o">]</span>


Example 1:

Input: <span class="nv">buildings</span> <span class="o">=</span> <span class="o">[[</span>2,9,10<span class="o">]</span>,<span class="o">[</span>3,7,15<span class="o">]</span>,<span class="o">[</span>5,12,12<span class="o">]</span>,<span class="o">[</span>15,20,10<span class="o">]</span>,<span class="o">[</span>19,24,8<span class="o">]]</span>
Output: <span class="o">[[</span>2,10<span class="o">]</span>,<span class="o">[</span>3,15<span class="o">]</span>,<span class="o">[</span>7,12<span class="o">]</span>,<span class="o">[</span>12,0<span class="o">]</span>,<span class="o">[</span>15,10<span class="o">]</span>,<span class="o">[</span>20,8<span class="o">]</span>,<span class="o">[</span>24,0<span class="o">]]</span>
Explanation:
Figure A shows the buildings of the input.
Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.
</code></pre></div><p>[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">getSkyline</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">buildings</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="cm">/*
</span><span class="cm">        [L, R, H]   -&gt; [L, R]       [R, H]
</span><span class="cm">        [[2,9,10],      [2,-10],    [9,10]
</span><span class="cm">        [3,7,15],       [3,-15],    [7,15] 
</span><span class="cm">        [5,12,12],      [5,-12],    [12,12]
</span><span class="cm">        [15,20,10],
</span><span class="cm">        [19,24,8]]
</span><span class="cm">        
</span><span class="cm">        用正负区分是左端点还是右端点
</span><span class="cm">        然后排列他们, 但是高度是按降序排列处理
</span><span class="cm">        [2,-10],
</span><span class="cm">        [3,-15],
</span><span class="cm">        [5,-12],
</span><span class="cm">         [7,15]
</span><span class="cm">         [9,10]
</span><span class="cm">        */</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">buildLines</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">points</span> <span class="o">:</span> <span class="n">buildings</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">buildLines</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">points</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="o">-</span><span class="n">points</span><span class="o">[</span><span class="n">2</span><span class="o">]});</span>
            <span class="n">buildLines</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">points</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">2</span><span class="o">]});</span>
        <span class="o">}</span>
        
        <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">buildLines</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">!=</span> <span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>
        
        <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">maxHeap</span> <span class="o">=</span> <span class="k">new</span>  <span class="n">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="o">);</span>
        <span class="n">maxHeap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">preHightest</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">points</span> <span class="o">:</span> <span class="n">buildLines</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">// h[1] &lt; 0, that means it meets a new building, so add it to pq
</span><span class="c1"></span>                <span class="n">maxHeap</span><span class="o">.</span><span class="na">add</span><span class="o">(-</span><span class="n">points</span><span class="o">[</span><span class="n">1</span><span class="o">]);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">maxHeap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">1</span><span class="o">]);</span> <span class="c1">// h[1] &gt;=0, that means it has reached the end of the building, so remove it from pq
</span><span class="c1"></span>            <span class="o">}</span>
            <span class="c1">// the current max height in all encountered buildings
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">curHeight</span> <span class="o">=</span> <span class="n">maxHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
             <span class="c1">// if the max height is different from the previous one, that means a critical point is met, add to result list
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">curHeight</span> <span class="o">!=</span> <span class="n">preHightest</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">curHeight</span><span class="o">));</span>
                <span class="n">preHightest</span> <span class="o">=</span> <span class="n">curHeight</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><p>Time complexity = O(n^2)</p>
<p>O(n) space</p>
<p>优先队列的 remove 操作需要先经过 O(n)O(n) 的复杂度进行查找，再通过 O(\log{n})O(logn) 的复杂度进行删除。因此整个 remove 操作的复杂度是 O(n)O(n) 的，这导致了我们算法整体复杂度为 O(n^2)</p>
<p>☕☕☕</p>
<p>O(nlogn) time</p>
<p>首先考虑，如果只给一个建筑 [x, y, h]，那么答案是多少？</p>
<p>很明显输出的解将会是 [[x, h], [y, 0]]，也就是左上角和右下角坐标。</p>
<p>接下来考虑，如果有建筑 A B C D E，我们知道了建筑 A B C 输出的解和 D E 输出的解，那么怎么把这两组解合并，得到 A B C D E 输出的解。</p>
<p>{{0,2,3},       {2,5,3}}</p>
<blockquote>
<p>left: [[0, 3], [2, 0]] //左上角, 右下</p>
</blockquote>
<blockquote>
<p>right: [[2, 3], [5, 0]] //左上角, 右下</p>
</blockquote>
<p><strong>第一轮， left:[0, 3], right:[2, 3]</strong></p>
<p>x1 = 0, x2 = 2</p>
<p>leftH = temp[1]; // 3</p>
<p>res.add[0, 3]</p>
<p><strong>第二轮， left:[2, 0], right:[2, 3]</strong></p>
<p>x1 = 2, x2 = 2</p>
<p>leftH = temp[1]; // 0 
rightH = right.pollFirst()[1]; // 3</p>
<p>res 不加</p>
<p><strong>第三轮， right:[5, 0]</strong></p>
<p>x = 5</p>
<p>rightH = right.pollFirst()[1]; // 0</p>
<p>res.add[5, 0]</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">getSkyline</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">buildings</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">merge</span><span class="o">(</span><span class="n">buildings</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">buildings</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="kd">private</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">buildings</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">LinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
     <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">buildings</span><span class="o">[</span><span class="n">lo</span><span class="o">][</span><span class="n">0</span><span class="o">],</span> <span class="n">buildings</span><span class="o">[</span><span class="n">lo</span><span class="o">][</span><span class="n">2</span><span class="o">]});</span> <span class="c1">//  [[x, h], [y, 0]]
</span><span class="c1"></span>         <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">buildings</span><span class="o">[</span><span class="n">lo</span><span class="o">][</span><span class="n">1</span><span class="o">],</span> <span class="n">0</span><span class="o">});</span>
         <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
     <span class="o">}</span>

     <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)/</span><span class="n">2</span><span class="o">;</span>
     <span class="n">LinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">left</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">buildings</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span> <span class="c1">// left: [[0, 3], [2, 0]] 
</span><span class="c1"></span>    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">right</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">buildings</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span> <span class="c1">// right: [[2, 3], [5, 0]]
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">leftH</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">rightH</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">left</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">right</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()?</span> <span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">:</span> <span class="n">left</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()[</span><span class="n">0</span><span class="o">];</span> <span class="c1">// 0
</span><span class="c1"></span>            <span class="kt">long</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()?</span> <span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">:</span> <span class="n">right</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()[</span><span class="n">0</span><span class="o">];</span> <span class="c1">// 2
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>  <span class="c1">// [0, 3]
</span><span class="c1"></span>                <span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">0</span><span class="o">];</span> <span class="c1">// 0
</span><span class="c1"></span>                <span class="n">leftH</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">1</span><span class="o">];</span> <span class="c1">// 3
</span><span class="c1"></span>            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
                <span class="n">rightH</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()[</span><span class="n">0</span><span class="o">];</span>
                <span class="n">leftH</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">()[</span><span class="n">1</span><span class="o">];</span>
                <span class="n">rightH</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">()[</span><span class="n">1</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftH</span><span class="o">,</span> <span class="n">rightH</span><span class="o">);</span>    <span class="c1">// 3
</span><span class="c1"></span>            <span class="k">if</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">res</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()[</span><span class="n">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="o">});</span> <span class="c1">// [0, 3]
</span><span class="c1"></span>            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
 
</code></pre></div><h2 id="non-overlapping-intervals-435">Non-overlapping Intervals 435</h2>
<p><a id="markdown-non-overlapping-intervals-435" name="non-overlapping-intervals-435"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an array of intervals intervals where intervals<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>starti, endi<span class="o">]</span>, <span class="k">return</span> the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

 

Example 1:

Input: <span class="nv">intervals</span> <span class="o">=</span> <span class="o">[[</span>1,2<span class="o">]</span>,<span class="o">[</span>2,3<span class="o">]</span>,<span class="o">[</span>3,4<span class="o">]</span>,<span class="o">[</span>1,3<span class="o">]]</span>
Output: <span class="m">1</span>
Explanation: <span class="o">[</span>1,3<span class="o">]</span> can be removed and the rest of the intervals are non-overlapping.
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">0</span><span class="o">;</span> 
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="n">1</span><span class="o">]);</span>
        
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">1</span><span class="o">];</span> 
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> 
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">){</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">];</span> 
                <span class="n">count</span><span class="o">++;</span> 
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">count</span><span class="o">;</span> 
    <span class="o">}</span>

    <span class="c1">//  int end = Integer.MIN_VALUE;
</span><span class="c1"></span>    <span class="c1">//     int count = 0;
</span><span class="c1"></span>    <span class="c1">//     for (Interval interval : intervals) {
</span><span class="c1"></span>    <span class="c1">//         if (interval.start &gt;= end) end = interval.end;
</span><span class="c1"></span>    <span class="c1">//         else count++;
</span><span class="c1"></span>    <span class="c1">//     }
</span><span class="c1"></span>
    <span class="c1">//     return count;
</span><span class="c1"></span>    <span class="c1">// }
</span><span class="c1"></span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">[[</span><span class="n">1</span><span class="o">,</span><span class="n">100</span><span class="o">],[</span><span class="n">11</span><span class="o">,</span><span class="n">22</span><span class="o">],[</span><span class="n">1</span><span class="o">,</span><span class="n">11</span><span class="o">],[</span><span class="n">2</span><span class="o">,</span><span class="n">12</span><span class="o">]]</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">]));</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="n">1</span><span class="o">]);</span> <span class="c1">//[1,11],[2,12], [11,22], [1,100]
</span><span class="c1"></span>        
        
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        
        
       
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 将 11 与2， 22，数组[0]z对比
</span><span class="c1"></span>                <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
                <span class="n">len</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">len</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">eraseOverlapIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">]));</span>
        <span class="kt">int</span> <span class="n">prevEnd</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">prevEnd</span> <span class="o">&gt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="n">prevEnd</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">],</span> <span class="n">prevEnd</span><span class="o">);</span> <span class="c1">// 把 11 和100 取最小的
</span><span class="c1"></span>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">prevEnd</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><h2 id="minimum-number-of-arrows-to-burst-balloons-452">Minimum Number of Arrows to Burst Balloons 452</h2>
<p><a id="markdown-minimum-number-of-arrows-to-burst-balloons-452" name="minimum-number-of-arrows-to-burst-balloons-452"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>xstart, xend<span class="o">]</span> denotes a balloon whose horizontal diameter stretches between xstart and xend. You <span class="k">do</span> not know the exact y-coordinates of the balloons.

Arrows can be shot up directly vertically <span class="o">(</span>in the positive y-direction<span class="o">)</span> from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x <span class="k">if</span> xstart &lt;<span class="o">=</span> x &lt;<span class="o">=</span> xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array points, <span class="k">return</span> the minimum number of arrows that must be shot to burst all balloons.

 

Example 1:

Input: <span class="nv">points</span> <span class="o">=</span> <span class="o">[[</span>10,16<span class="o">]</span>,<span class="o">[</span>2,8<span class="o">]</span>,<span class="o">[</span>1,6<span class="o">]</span>,<span class="o">[</span>7,12<span class="o">]]</span>
Output: <span class="m">2</span>
Explanation: The balloons can be burst by <span class="m">2</span> arrows:
- Shoot an arrow at <span class="nv">x</span> <span class="o">=</span> 6, bursting the balloons <span class="o">[</span>2,8<span class="o">]</span> and <span class="o">[</span>1,6<span class="o">]</span>.
- Shoot an arrow at <span class="nv">x</span> <span class="o">=</span> 11, bursting the balloons <span class="o">[</span>10,16<span class="o">]</span> and <span class="o">[</span>7,12<span class="o">]</span>.
</code></pre></div><p><strong>wrong answer, sort with a[0]</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMinArrowShots</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">0</span><span class="o">],</span><span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">]));</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">1</span><span class="o">];</span> <span class="c1">// 6
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
            <span class="o">}</span> 
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div><blockquote>
<p>[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]</p>
</blockquote>
<p>按我的结果</p>
<blockquote>
<p>[0,9] [0,6][2,9] [2,8] [3,9] [3,8] [3,9][6,8][7,12][9,10]</p>
</blockquote>
<p>tmp = 9, 所以我只会用一个， 然后 [3,8]，这个 case 我就射不到</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMinArrowShots</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">1</span><span class="o">],</span><span class="n">b</span><span class="o">[</span><span class="n">1</span><span class="o">]));</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">1</span><span class="o">];</span> <span class="c1">// 6
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
            <span class="o">}</span> 
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><h2 id="my-calendar-i-729">My Calendar I 729</h2>
<p><a id="markdown-my-calendar-i-729" name="my-calendar-i-729"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are implementing a program to use as your calendar. We can add a new event <span class="k">if</span> adding the event will not cause a double booking.

A double booking happens when two events have some non-empty intersection <span class="o">(</span>i.e., some moment is common to both events.<span class="o">)</span>.

The event can be represented as a pair of integers start and end that represents a booking on the half-open interval <span class="o">[</span>start, end<span class="o">)</span>, the range of real numbers x such that start &lt;<span class="o">=</span> x &lt; end.

Implement the MyCalendar class:

MyCalendar<span class="o">()</span> Initializes the calendar object.
boolean book<span class="o">(</span>int start, int end<span class="o">)</span> Returns <span class="nb">true</span> <span class="k">if</span> the event can be added to the calendar successfully without causing a double booking. Otherwise, <span class="k">return</span> <span class="nb">false</span> and <span class="k">do</span> not add the event to the calendar.
 

Example 1:

Input
<span class="o">[</span><span class="s2">&#34;MyCalendar&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span><span class="o">]</span>
<span class="o">[[]</span>, <span class="o">[</span>10, 20<span class="o">]</span>, <span class="o">[</span>15, 25<span class="o">]</span>, <span class="o">[</span>20, 30<span class="o">]]</span>
Output
<span class="o">[</span>null, true, false, true<span class="o">]</span>
</code></pre></div><ol>
<li>a0|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|a1</li>
</ol>
<p>.        b0|&mdash;&mdash;b1</p>
<ol start="2">
<li>a0|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|a1</li>
</ol>
<p>.        b0|&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;b1</p>
<ol start="3">
<li>a0|&mdash;&mdash;&mdash;|a1</li>
</ol>
<p>.                   b0|&mdash;&mdash;&mdash;&mdash;-b1</p>
<p>错误的答案， 我一开始想的是只有为 true 的数据往后插，可是忽略了一个条件就是插头插中间了，那就不能按我的只对比尾巴的那个</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">});</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">tmp</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">start</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">tmp</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">end</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">});</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        
        
       
    <span class="o">}</span>
</code></pre></div><blockquote>
<p>[&ldquo;MyCalendar&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;,&ldquo;book&rdquo;]
[[],[47,50],[33,41],[39,45],[33,42],[25,32],[26,35],[19,25],[3,8],[8,13],[18,27]]</p>
</blockquote>
<p>我的</p>
<blockquote>
<p>[null,true,true,false,false,true,false,true,true,true,true]</p>
</blockquote>
<blockquote>
<p>[null,true,true,false,false,true,false,true,true,true,false]</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">     <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
       
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tmp</span> <span class="o">:</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">tmp</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">start</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">tmp</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">end</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="o">}</span>
       
        
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">});</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                  
    <span class="o">}</span>
</code></pre></div><p>每次都要遍历一边，所以按我的想法让它排序好, map 来建立起始时间和结束时间的映射，map 会按照起始时间进行自动排序。然后对于新进来的区间，我们在已有区间中查找第一个不小于新入区间的起始时间的区间, 当前区间起始时间小于新入区间结束时间的话返回 false, 如果前一个区间的结束时间大于新入区间的起始时间的话，返回 false。否则就建立新的映射，返回 true 即可</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">     <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">lowerEntry</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">lowerEntry</span><span class="o">(</span><span class="n">end</span><span class="o">);</span> <span class="c1">// start1 == end will not be seen as overlap
</span><span class="c1"></span>        <span class="k">if</span><span class="o">(</span><span class="n">lowerEntry</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">lowerEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// or use or the condition as authors posts
</span><span class="c1"></span>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
     
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><h2 id="my-calendar-ii-731">My Calendar II 731</h2>
<p><a id="markdown-my-calendar-ii-731" name="my-calendar-ii-731"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">ou are implementing a program to use as your calendar. We can add a new event <span class="k">if</span> adding the event will not cause a triple booking.

A triple booking happens when three events have some non-empty intersection <span class="o">(</span>i.e., some moment is common to all the three events.<span class="o">)</span>.

The event can be represented as a pair of integers start and end that represents a booking on the half-open interval <span class="o">[</span>start, end<span class="o">)</span>, the range of real numbers x such that start &lt;<span class="o">=</span> x &lt; end.

Implement the MyCalendarTwo class:

MyCalendarTwo<span class="o">()</span> Initializes the calendar object.
boolean book<span class="o">(</span>int start, int end<span class="o">)</span> Returns <span class="nb">true</span> <span class="k">if</span> the event can be added to the calendar successfully without causing a triple booking. Otherwise, <span class="k">return</span> <span class="nb">false</span> and <span class="k">do</span> not add the event to the calendar.
 

Example 1:

Input
<span class="o">[</span><span class="s2">&#34;MyCalendarTwo&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span><span class="o">]</span>
<span class="o">[[]</span>, <span class="o">[</span>10, 20<span class="o">]</span>, <span class="o">[</span>50, 60<span class="o">]</span>, <span class="o">[</span>10, 40<span class="o">]</span>, <span class="o">[</span>5, 15<span class="o">]</span>, <span class="o">[</span>5, 10<span class="o">]</span>, <span class="o">[</span>25, 55<span class="o">]]</span>
Output
<span class="o">[</span>null, true, true, true, false, true, true<span class="o">]</span>

</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MyCalendarTwo</span> <span class="o">{</span>

  
        <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">books</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        
       <span class="n">MyCalendar</span> <span class="n">overlaps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyCalendar</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">:</span> <span class="n">books</span><span class="o">)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">start</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">end</span><span class="o">))</span> <span class="c1">// overlap exist
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(!</span><span class="n">overlaps</span><span class="o">.</span><span class="na">book</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">start</span><span class="o">),</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">end</span><span class="o">)))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// overlaps overlapped
</span><span class="c1"></span>        <span class="n">books</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span> <span class="o">});</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyCalendar</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">books</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">:</span> <span class="n">books</span><span class="o">)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">start</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">b</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">end</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">books</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span> <span class="o">});</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>O(N^2)</p>
<p>O(N^2)插旗法</p>
<p>[10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]</p>
<ul>
<li>10 1</li>
<li>20 -1</li>
</ul>
<ul>
<li>50 1</li>
<li>60 -1</li>
</ul>
<p>[10, 40], [5, 15], [5, 10], [25, 55]</p>
<ul>
<li>5  1</li>
<li>10 3 // [5, 15] false</li>
<li>20 -1</li>
</ul>
<ul>
<li>40 -1</li>
<li>50 1</li>
<li>60 -1</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">
<span class="kd">class</span> <span class="nc">MyCalendarTwo</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>
    
    <span class="kd">class</span> <span class="nf">MyCalendarTwo</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">0</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">3</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 取消这次行程
</span><span class="c1"></span>                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">0</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
               
                <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">start</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
                 <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">end</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">end</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="c1">//  ConcurrentModificationException is thrown when the iterator checks the size of the map in method &#34;iterator.hasNext()&#34; 因为这里直接return 了
</span><span class="c1"></span>                <span class="c1">//所以没有抛出错误
</span><span class="c1"></span>            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>这个题，需要的最少 meeting room 的数量，和上面的题稍微有点不同。不同之处主要是如何放置当前会议的时间段，需要去找到过去已经放置好的时段里的最早结束时间，如果当前时段的开始时间晚于这个时间，就可以放到该会议时段的后面，也就是不需要新的会议室。所以需要存储以前所有的会议时段。考虑到每次需要出栈的是以前的最早结束的会议，所以采用小根堆存储，每次出栈的是按照最小的结束时间为标准。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minMeetingRooms</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">intervals</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">start</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">start</span><span class="o">);</span>
 
        <span class="c1">// 小根堆，存储会议，出堆按照结束会议的最早时间
</span><span class="c1"></span>        <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">minHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">end</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">end</span><span class="o">);</span>
        <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>
 
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">Interval</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">Interval</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">start</span> <span class="o">&gt;=</span> <span class="n">prev</span><span class="o">.</span><span class="na">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 没有交叉，可以分配到同一个时间，将end时间延长
</span><span class="c1"></span>                <span class="n">prev</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">prev</span><span class="o">.</span><span class="na">end</span><span class="o">,</span> <span class="n">curr</span><span class="o">.</span><span class="na">end</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 交叉，offer当前的时间间隔
</span><span class="c1"></span>                <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">curr</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">prev</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>


</code></pre></div><h2 id="my-calendar-iii-732">My Calendar III 732</h2>
<p><a id="markdown-my-calendar-iii-732" name="my-calendar-iii-732"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">A k-booking happens when k events have some non-empty intersection <span class="o">(</span>i.e., there is some <span class="nb">time</span> that is common to all k events.<span class="o">)</span>

You are given some events <span class="o">[</span>start, end<span class="o">)</span>, after each given event, <span class="k">return</span> an integer k representing the maximum k-booking between all the previous events.

Implement the MyCalendarThree class:

MyCalendarThree<span class="o">()</span> Initializes the object.
int book<span class="o">(</span>int start, int end<span class="o">)</span> Returns an integer k representing the largest integer such that there exists a k-booking in the calendar.
 

Example 1:

Input
<span class="o">[</span><span class="s2">&#34;MyCalendarThree&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span>, <span class="s2">&#34;book&#34;</span><span class="o">]</span>
<span class="o">[[]</span>, <span class="o">[</span>10, 20<span class="o">]</span>, <span class="o">[</span>50, 60<span class="o">]</span>, <span class="o">[</span>10, 40<span class="o">]</span>, <span class="o">[</span>5, 15<span class="o">]</span>, <span class="o">[</span>5, 10<span class="o">]</span>, <span class="o">[</span>25, 55<span class="o">]]</span>
Output
<span class="o">[</span>null, 1, 1, 2, 3, 3, 3<span class="o">]</span>
</code></pre></div><p>[10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]</p>
<ul>
<li>10 1</li>
<li>20 -1</li>
</ul>
<ul>
<li>50 1</li>
<li>60 -1</li>
</ul>
<p>[10, 40], [5, 15], [5, 10], [25, 55]</p>
<ul>
<li>5 2</li>
</ul>
<ul>
<li>10 3 //[10, 40] -&gt;  2 [5, 15] -&gt; 3 [5, 10] -&gt; 3</li>
</ul>
<ul>
<li>15 -1</li>
</ul>
<ul>
<li>20 -1</li>
</ul>
<ul>
<li>40 -1</li>
<li>50 1</li>
<li>60 -1</li>
</ul>
<p>O(N^2)</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">
</code></pre></div><h2 id="describe-the-painting-1943">Describe the Painting 1943</h2>
<p><a id="markdown-describe-the-painting-1943" name="describe-the-painting-1943"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a unique color. You are given a 2D integer array segments, where segments<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>starti, endi, colori<span class="o">]</span> represents the half-closed segment <span class="o">[</span>starti, endi<span class="o">)</span> with colori as the color.

The colors in the overlapping segments of the painting were mixed when it was painted. When two or more colors mix, they form a new color that can be represented as a <span class="nb">set</span> of mixed colors.

For example, <span class="k">if</span> colors 2, 4, and <span class="m">6</span> are mixed, <span class="k">then</span> the resulting mixed color is <span class="o">{</span>2,4,6<span class="o">}</span>.
For the sake of simplicity, you should only output the sum of the elements in the <span class="nb">set</span> rather than the full set.

You want to describe the painting with the minimum number of non-overlapping half-closed segments of these mixed colors. These segments can be represented by the 2D array painting where painting<span class="o">[</span>j<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>leftj, rightj, mixj<span class="o">]</span> describes a half-closed segment <span class="o">[</span>leftj, rightj<span class="o">)</span> with the mixed color sum of mixj.

For example, the painting created with <span class="nv">segments</span> <span class="o">=</span> <span class="o">[[</span>1,4,5<span class="o">]</span>,<span class="o">[</span>1,7,7<span class="o">]]</span> can be described by <span class="nv">painting</span> <span class="o">=</span> <span class="o">[[</span>1,4,12<span class="o">]</span>,<span class="o">[</span>4,7,7<span class="o">]]</span> because:
<span class="o">[</span>1,4<span class="o">)</span> is colored <span class="o">{</span>5,7<span class="o">}</span> <span class="o">(</span>with a sum of 12<span class="o">)</span> from both the first and second segments.
<span class="o">[</span>4,7<span class="o">)</span> is colored <span class="o">{</span>7<span class="o">}</span> from only the second segment.
Return the 2D array painting describing the finished painting <span class="o">(</span>excluding any parts that are not painted<span class="o">)</span>. You may <span class="k">return</span> the segments in any order.

A half-closed segment <span class="o">[</span>a, b<span class="o">)</span> is the section of the number line between points a and b including point a and not including point b.

Example 1:

Input: <span class="nv">segments</span> <span class="o">=</span> <span class="o">[[</span>1,4,5<span class="o">]</span>,<span class="o">[</span>4,7,7<span class="o">]</span>,<span class="o">[</span>1,7,9<span class="o">]]</span>
Output: <span class="o">[[</span>1,4,14<span class="o">]</span>,<span class="o">[</span>4,7,16<span class="o">]]</span>
Explanation: The painting can be described as follows:
- <span class="o">[</span>1,4<span class="o">)</span> is colored <span class="o">{</span>5,9<span class="o">}</span> <span class="o">(</span>with a sum of 14<span class="o">)</span> from the first and third segments.
- <span class="o">[</span>4,7<span class="o">)</span> is colored <span class="o">{</span>7,9<span class="o">}</span> <span class="o">(</span>with a sum of 16<span class="o">)</span> from the second and third segments.
</code></pre></div><p><strong>Iterate on all the segments(start, end, color) of the painting and add color value at start and subtract it at end. Use TreeMap to store the points sorted. Keep adding the value of color at each point to know the current value at that point.</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="nf">splitPainting</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">segments</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;&gt;();</span>

	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">segment</span><span class="o">[]:</span> <span class="n">segments</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">segment</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">segment</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">0L</span><span class="o">)</span> <span class="o">+</span> <span class="n">segment</span><span class="o">[</span><span class="n">2</span><span class="o">]);</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">segment</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">segment</span><span class="o">[</span><span class="n">1</span><span class="o">],</span> <span class="n">0L</span><span class="o">)</span> <span class="o">-</span> <span class="n">segment</span><span class="o">[</span><span class="n">2</span><span class="o">]);</span>
	<span class="o">}</span>

	<span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

	<span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
	<span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Ignore the unpainted interval
</span><span class="c1"></span>			<span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">prev</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">key</span><span class="o">,</span> <span class="n">sum</span><span class="o">));</span> <span class="c1">// Add the interval
</span><span class="c1"></span>		<span class="o">}</span>

		<span class="n">sum</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="falling-squares-699">Falling Squares 699</h2>
<p><a id="markdown-falling-squares-699" name="falling-squares-699"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">There are several squares being dropped onto the X-axis of a 2D plane.

You are given a 2D integer array positions where positions<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>lefti, sideLengthi<span class="o">]</span> represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.

Each square is dropped one at a <span class="nb">time</span> from a height above any landed squares. It <span class="k">then</span> falls downward <span class="o">(</span>negative Y direction<span class="o">)</span> <span class="k">until</span> it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.

After each square is dropped, you must record the height of the current tallest stack of squares.

Return an integer array ans where ans<span class="o">[</span>i<span class="o">]</span> represents the height described above after dropping the ith square.

 

Example 1:


Input: <span class="nv">positions</span> <span class="o">=</span> <span class="o">[[</span>1,2<span class="o">]</span>,<span class="o">[</span>2,3<span class="o">]</span>,<span class="o">[</span>6,1<span class="o">]]</span>
Output: <span class="o">[</span>2,5,5<span class="o">]</span>
Explanation:
After the first drop, the tallest stack is square <span class="m">1</span> with a height of 2.
After the second drop, the tallest stack is squares <span class="m">1</span> and <span class="m">2</span> with a height of 5.
After the third drop, the tallest stack is still squares <span class="m">1</span> and <span class="m">2</span> with a height of 5.
Thus, we <span class="k">return</span> an answer of <span class="o">[</span>2, 5, 5<span class="o">]</span>.
</code></pre></div><p>[1,2],[2,3],[6,1]</p>
<p>start 1 end = 3</p>
<p>from = 0;</p>
<p>height = height = startHeight.subMap(from, end).values().stream().max(Integer::compare).get() + pos[1]; // 2</p>
<p>res: 2</p>
<p>第一轮后：[1,2]
treemap：[0,0], [1,2], [3, 0]</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"></code></pre></div><h2 id="task-scheduler-621">Task Scheduler 621</h2>
<p><a id="markdown-task-scheduler-621" name="task-scheduler-621"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given a characters array tasks, representing the tasks a CPU needs to <span class="k">do</span>, where each letter represents a different task. Tasks could be <span class="k">done</span> in any order. Each task is <span class="k">done</span> in one unit of time. For each unit of time, the CPU could <span class="nb">complete</span> either one task or just be idle.

However, there is a non-negative integer n that represents the cooldown period between two same tasks <span class="o">(</span>the same letter in the array<span class="o">)</span>, that is that there must be at least n units of <span class="nb">time</span> between any two same tasks.

Return the least number of units of <span class="nb">times</span> that the CPU will take to finish all the given tasks.

 

Example 1:

Input: <span class="nv">tasks</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;A&#34;</span>,<span class="s2">&#34;A&#34;</span>,<span class="s2">&#34;A&#34;</span>,<span class="s2">&#34;B&#34;</span>,<span class="s2">&#34;B&#34;</span>,<span class="s2">&#34;B&#34;</span><span class="o">]</span>, <span class="nv">n</span> <span class="o">=</span> <span class="m">2</span>
Output: <span class="m">8</span>
Explanation: 
A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B
There is at least <span class="m">2</span> units of <span class="nb">time</span> between any two same tasks.
</code></pre></div><ol start="7">
<li>Pattern: Tree Breadth First Search，树上的BFS
这种模式基于宽搜（Breadth First Search (BFS)），适用于需要遍历一颗树。借助于队列数据结构，从而能保证树的节点按照他们的层数打印出来。打印完当前层所有元素，才能执行到下一层。所有这种需要遍历树且需要一层一层遍历的问题，都能用这种模式高效解决。</li>
</ol>
<p>这种树上的BFS模式是通过把根节点加到队列中，然后不断遍历直到队列为空。每一次循环中，我们都会把队头结点拿出来（remove），然后对其进行必要的操作。在删除每个节点的同时，其孩子节点，都会被加到队列中。</p>
<p>识别树上的BFS模式：</p>
<p>如果你被问到去遍历树，需要按层操作的方式（也称作层序遍历）
经典题目：</p>
<p>Binary Tree Level Order Traversal (easy)</p>
<p>Reverse Level Order Traversal (easy)</p>
<p>Zigzag Traversal (medium)</p>
<p>Level Averages in a Binary Tree (easy)</p>
<p>Minimum Depth of a Binary Tree (easy)</p>
<p>Level Order Successor (easy)</p>
<p>Connect Level Order Siblings (medium)</p>
<ol start="8">
<li>Pattern: Tree Depth First Search，树上的DFS
树形DFS基于深搜（Depth First Search (DFS)）技术来实现树的遍历。</li>
</ol>
<p>咱们可以用递归（或是显示栈，如果你想用迭代方式的话）来记录遍历过程中访问过的父节点。</p>
<p>该模式的运行方式是从根节点开始，如果该节点不是叶子节点，我们需要干三件事：</p>
<p>需要区别我们是先处理根节点（pre-order，前序），处理孩子节点之间处理根节点（in-order，中序），还是处理完所有孩子再处理根节点（post-order，后序）。
递归处理当前节点的左右孩子。
识别树形DFS：</p>
<p>你需要按前中后序的DFS方式遍历树
如果该问题的解一般离叶子节点比较近。
经典题目：</p>
<p>Binary Tree Path Sum (easy)</p>
<p>All Paths for a Sum (medium)</p>
<p>Sum of Path Numbers (medium)</p>
<p>Path With Given Sequence (medium)</p>
<p>Count Paths for a Sum (medium)</p>
<ol start="9">
<li>Pattern: Two Heaps，双堆类型
很多问题中，我们被告知，我们拿到一大把可以分成两队的数字。为了解决这个问题，我们感兴趣的是，怎么把数字分成两半？使得：小的数字都放在一起，大的放在另外一半。双堆模式就能高效解决此类问题。</li>
</ol>
<p>正如名字所示，该模式用到了两个堆，是不是很难猜？一个最小堆用来找最小元素；一个最大堆，拿到最大元素。这种模式将一半的元素放在最大堆中，这样你可以从这一堆中秒找到最大元素。同理，把剩下一半丢到最小堆中，O(1)时间找到他们中的最小元素。通过这样的方式，这一大堆元素的中位数就可以从两个堆的堆顶拿到数字，从而计算出来。</p>
<p>判断双堆模式的秘诀：</p>
<p>这种模式在优先队列，计划安排问题（Scheduling）中有奇效
如果问题让你找一组数中的最大/最小/中位数
有时候，这种模式在涉及到二叉树数据结构时也特别有用
经典题目：</p>
<p>Find the Median of a Number Stream (medium)</p>
<p>Sliding Window Median (hard)</p>
<p>Maximize Capital (hard)</p>
<ol start="10">
<li>Pattern: Subsets，子集类型，一般都是使用多重DFS
超级多的编程面试问题都会涉及到排列和组合问题。子集问题模式讲的是用BFS来处理这些问题。</li>
</ol>
<p>这个模式是这样的：</p>
<p>给一组数字 [1, 5, 3]</p>
<p>我们从空集开始：[[]]
把第一个数（1），加到之前已经存在的集合中：[[], [1]];
把第二个数（5），加到之前的集合中得到：[[], [1], [5], [1,5]];
再加第三个数（3），则有：[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]].
该模式的详细步骤如下：</p>
<p>如果判断这种子集模式：</p>
<p>问题需要咱们去找数字的组合或是排列
经典题目：</p>
<p>Subsets (easy)</p>
<p>Subsets With Duplicates (easy)</p>
<p>Permutations (medium)</p>
<p>String Permutations by changing case (medium)</p>
<p>Balanced Parentheses (hard)</p>
<p>Unique Generalized Abbreviations (hard)</p>
<ol start="11">
<li>Pattern: Modified Binary Search，改造过的二分
当你需要解决的问题的输入是排好序的数组，链表，或是排好序的矩阵，要求咱们寻找某些特定元素。这个时候的不二选择就是二分搜索。这种模式是一种超级牛的用二分来解决问题的方式。</li>
</ol>
<p>对于一组满足上升排列的数集来说，这种模式的步骤是这样的：</p>
<p>首先，算出左右端点的中点。最简单的方式是这样的：middle = (start + end) / 2。但这种计算方式有不小的概率会出现整数越界。因此一般都推荐另外这种写法：middle = start + (end — start) / 2
如果要找的目标改好和中点所在的数值相等，我们返回中点的下标就行
如果目标不等的话：我们就有两种移动方式了
如果目标比中点在的值小（key &lt; arr[middle]）：将下一步搜索空间放到左边（end = middle - 1）
如果比中点的值大，则继续在右边搜索，丢弃左边：left = middle + 1
图示该过程的话，如下图所示：</p>
<p>经典题目：</p>
<p>Order-agnostic Binary Search (easy)</p>
<p>Ceiling of a Number (medium)</p>
<p>Next Letter (medium)</p>
<p>Number Range (medium)</p>
<p>Search in a Sorted Infinite Array (medium)</p>
<p>Minimum Difference Element (medium)</p>
<p>Bitonic Array Maximum (easy)</p>
<ol start="12">
<li>Pattern: Top ‘K’ Elements，前K个系列
任何让我们求解最大/最小/最频繁的K个元素的题，都遵循这种模式。</li>
</ol>
<p>用来记录这种前K类型的最佳数据结构就是堆了（译者注：在Java中，改了个名，叫优先队列（PriorityQueue））。这种模式借助堆来解决很多这种前K个数值的问题。</p>
<p>这个模式是这样的：</p>
<p>根据题目要求，将K个元素插入到最小堆或是最大堆。
遍历剩下的还没访问的元素，如果当前出来到的这个元素比堆顶元素大，那咱们把堆顶元素先删除，再加当前元素进去。</p>
<p>注意这种模式下，咱们不需要去排序数组，因为堆具有这种良好的局部有序性，这对咱们需要解决问题就够了。</p>
<p>识别最大K个元素模式：</p>
<p>如果你需要求最大/最小/最频繁的前K个元素
如果你需要通过排序去找一个特定的数
经典题目：</p>
<p>Top ‘K’ Numbers (easy)</p>
<p>Kth Smallest Number (easy)</p>
<p>‘K’ Closest Points to the Origin (easy)</p>
<p>Connect Ropes (easy)</p>
<p>Top ‘K’ Frequent Numbers (medium)</p>
<p>Frequency Sort (medium)</p>
<p>Kth Largest Number in a Stream (medium)</p>
<p>‘K’ Closest Numbers (medium)</p>
<p>Maximum Distinct Elements (medium)</p>
<p>Sum of Elements (medium)</p>
<p>Rearrange String (hard)</p>
<ol start="13">
<li>Pattern: K-way merge，多路归并
K路归并能帮咱们解决那些涉及到多组排好序的数组的问题。</li>
</ol>
<p>每当你的输入是K个排好序的数组，你就可以用堆来高效顺序遍历其中所有数组的所有元素。你可以将每个数组中最小的一个元素加入到最小堆中，从而得到全局最小值。当我们拿到这个全局最小值之后，再从该元素所在的数组里取出其后面紧挨着的元素，加入堆。如此往复直到处理完所有的元素。</p>
<p>该模式是这样的运行的：</p>
<p>把每个数组中的第一个元素都加入最小堆中
取出堆顶元素（全局最小），将该元素放入排好序的结果集合里面
将刚取出的元素所在的数组里面的下一个元素加入堆
重复步骤2，3，直到处理完所有数字
识别K路归并：</p>
<p>该问题的输入是排好序的数组，链表或是矩阵
如果问题让咱们合并多个排好序的集合，或是需要找这些集合中最小的元素
经典题目：</p>
<p>Merge K Sorted Lists (medium)</p>
<p>Kth Smallest Number in M Sorted Lists (Medium)</p>
<p>Kth Smallest Number in a Sorted Matrix (Hard)</p>
<p>Smallest Number Range (Hard)</p>
<ol start="14">
<li>Pattern: 0/1 Knapsack (Dynamic Programming)，0/1背包类型</li>
</ol>
<p><a href="https://leetcode.com/list/5ve5zu13/">https://leetcode.com/list/5ve5zu13/</a></p>
<p>经典题目：</p>
<p>0/1 Knapsack (medium)</p>
<p>Equal Subset Sum Partition (medium)</p>
<p>Subset Sum (medium)</p>
<p>Minimum Subset Sum Difference (hard)</p>
<ol start="15">
<li>Pattern: Topological Sort (Graph)，拓扑排序类型
拓扑排序模式用来寻找一种线性的顺序，这些元素之间具有依懒性。比如，如果事件B依赖于事件A，那A在拓扑排序顺序中排在B的前面。</li>
</ol>
<p>这种模式定义了一种简单方式来理解拓扑排序这种技术。</p>
<p>这种模式是这样奏效的：</p>
<p>初始化 a) 借助于HashMap将图保存成邻接表形式。 b) 找到所有的起点，用HashMap来帮助记录每个节点的入度
创建图，找到每个节点的入度 a) 利用输入，把图建好，然后遍历一下图，将入度信息记录在HashMap中
找所有的起点 a) 所有入度为0的节点，都是有效的起点，而且我们讲他们都加入到一个队列中
排序 a) 对每个起点，执行以下步骤 —i) 把它加到结果的顺序中 — ii)将其在图中的孩子节点取到 — iii)将其孩子的入度减少1 — iv)如果孩子的入度变为0，则改孩子节点成为起点，将其加入队列中 b) 重复（a）过程，直到起点队列为空。</p>
<p>拓扑排序模式识别：</p>
<p>待解决的问题需要处理无环图
你需要以一种有序的秩序更新输入元素
需要处理的输入遵循某种特定的顺序
经典题目：</p>
<p>Topological Sort (medium)</p>
<p>Tasks Scheduling (medium)</p>
<p>Tasks Scheduling Order (medium)</p>
<p>All Tasks Scheduling Orders (hard)</p>
<p>Alien Dictionary (hard)</p>
<p>大家好好练练这些题目，面试中遇到中高等难度的题目，应该就能解得不错了。</p>
<p>第二门则是单独将动态规划（DP）的题目进行了细分。</p>
<p>提到算法，绕不开的重点和难点就肯定会包括动态规划 &ndash; DP，本文就把经典的DP问题按照分类列一下，大家可以按照Recursion，Top-Down，Bottom-Up三种方式都练一练。俗话说，熟能生巧，多练才是提高算法的不二法宝。</p>
<p>课程详细的内容，可以参考这里：</p>
<p>Grokking Dynamic Programming Patterns for Coding Interviews
​www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews?aff=K7qB</p>
<p>该门课程中, 作者将DP的问题分成以下几类:</p>
<ol>
<li>0/1 Knapsack, 0/1背包，6个题
0/1 Knapsack，0/1背包问题</li>
</ol>
<p>Equal Subset Sum Partition，相等子集划分问题</p>
<p>Subset Sum，子集和问题</p>
<p>Minimum Subset Sum Difference，子集和的最小差问题</p>
<p>Count of Subset Sum，相等子集和的个数问题</p>
<p>Target Sum，寻找目标和的问题</p>
<ol start="2">
<li>Unbounded Knapsack，无限背包，5个题
Unbounded Knapsack，无限背包</li>
</ol>
<p>Rod Cutting，切钢条问题</p>
<p>Coin Change，换硬币问题</p>
<p>Minimum Coin Change，凑齐每个数需要的最少硬币问题</p>
<p>Maximum Ribbon Cut，丝带的最大值切法</p>
<ol start="3">
<li>Fibonacci Numbers，斐波那契数列，6个题
Fibonacci numbers，斐波那契数列问题</li>
</ol>
<p>Staircase，爬楼梯问题</p>
<p>Number factors，分解因子问题</p>
<p>Minimum jumps to reach the end，蛙跳最小步数问题</p>
<p>Minimum jumps with fee，蛙跳带有代价的问题</p>
<p>House thief，偷房子问题</p>
<ol start="4">
<li>Palindromic Subsequence，回文子系列，5个题
Longest Palindromic Subsequence，最长回文子序列</li>
</ol>
<p>Longest Palindromic Substring，最长回文子字符串</p>
<p>Count of Palindromic Substrings，最长子字符串的个数问题</p>
<p>Minimum Deletions in a String to make it a Palindrome，怎么删掉最少字符构成回文</p>
<p>Palindromic Partitioning，怎么分配字符，形成回文</p>
<ol start="5">
<li>Longest Common Substring，最长子字符串系列，13个题
Longest Common Substring，最长相同子串</li>
</ol>
<p>Longest Common Subsequence，最长相同子序列</p>
<p>Minimum Deletions &amp; Insertions to Transform a String into another，字符串变换</p>
<p>Longest Increasing Subsequence，最长上升子序列</p>
<p>Maximum Sum Increasing Subsequence，最长上升子序列和</p>
<p>Shortest Common Super-sequence，最短超级子序列</p>
<p>Minimum Deletions to Make a Sequence Sorted，最少删除变换出子序列</p>
<p>Longest Repeating Subsequence，最长重复子序列</p>
<p>Subsequence Pattern Matching，子序列匹配</p>
<p>Longest Bitonic Subsequence，最长字节子序列</p>
<p>Longest Alternating Subsequence，最长交差变换子序列</p>
<p>Edit Distance，编辑距离</p>
<p>Strings Interleaving，交织字符串</p>
<p>😼😼😼😼</p>
<ul>
<li>😼<a href="https://rileyshen.github.io/post/2pointers1/" >2pointers1</a></li>
<li>😼<a href="https://rileyshen.github.io/post/slidewindow1/" >slidewindow1</a></li>
<li>😼<a href="https://rileyshen.github.io/post/fastslow1/" >fastslowpoint</a></li>
</ul>
<hr>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/MPnaiL</p>
<p>感谢：她们都有题库在 github 上直接有，都是大神, 都富有详细解法，对新人特别适合了解解题思路</p>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/wtcaE1/solution/jian-dan-yi-dong-javac-pythonjshua-dong-dtang/">https://leetcode-cn.com/problems/wtcaE1/solution/jian-dan-yi-dong-javac-pythonjshua-dong-dtang/</a></p>
</li>
<li>
<p>宫水三叶</p>
</li>
<li>
<p>Grandyang (<a href="https://www.cnblogs.com/grandyang/">https://www.cnblogs.com/grandyang/</a>)</p>
</li>
<li>
<p>花花酱（油管频道视频）</p>
</li>
</ul>
</div>
    <div class="post-footer">
        <div class="info">
            
            <span class="separator"><a class="tag" href="/tags/java/">java</a><a class="tag" href="/tags/java-interview/">java interview</a><a class="tag" href="/tags/algorithm/">algorithm</a><a class="tag" href="/tags/merge-intervals/">Merge Intervals</a></span>
        </div>
    </div>

    
</div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js"
        integrity="sha256-g8sd1f6o1C2H0eYBoH&#43;qcwia0O&#43;cz&#43;Xa9gQSievMTkY="
        crossorigin="anonymous"></script>
<script async defer src="//latest.js"></script>
<noscript><img src="//noscript.gif" alt=""/></noscript>

</body>

</html>
