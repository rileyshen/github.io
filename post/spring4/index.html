<!DOCTYPE html>
<html  dir="ltr" lang="en" data-theme=""><head>
    <title> Riley Shen | spring learning code 4 </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.83.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description"
        content="spring learning code">
    <meta name="google-site-verification" content="Nac1UrFTdr1E1F48JLe7XQhIbKn2_WtF4VnJI8KOtew" />
    

    
    
    
    <link rel="stylesheet" href="/css/main.min.a7c9793b97840076bef76d2743ee1c90b13bd21c18674076a0cccd5dd54c723b.css" integrity="sha256-p8l5O5eEAHa&#43;920nQ&#43;4ckLE70hwYZ0B2oMzNXdVMcjs="
        crossorigin="anonymous" type="text/css">
    
    
    <link rel="stylesheet" href="/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css"
        integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS&#43;yuWSR4=" crossorigin="anonymous" type="text/css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
        integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
        crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">

    <link rel="canonical" href="/post/spring4/">

    <link rel="preconnect" href="https://fonts.gstatic.com">



    
    
    
    
    <script type="text/javascript" src="/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js"
        integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ=" crossorigin="anonymous"></script>


    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://rileyshen.github.io/images/site-feature-image.png"/>

<meta name="twitter:title" content="spring learning code 4"/>
<meta name="twitter:description" content="spring learning code"/>


    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,300;0,400;0,500;0,600;0,700;1,500;1,600;1,700&display=swap"
        rel="stylesheet">

</head><body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="/images/profileS.jpg" alt="profile picture">
            <h3 title=""><a href="/">I&#39;m Riley Shen</a></h3>
            <div class="description">
                <p><br>Riley likes to push her limits <br>and always keep learning new things. <br>She shares her weekly learnings <br>because "if you can't explain it simply,<br>it means you didn't understand it well enough".<br></p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="mailto:ripple.shen31@gmail.com" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://github.com/rileyshen" rel="me" aria-label="GitHub">
                    <i class="fab fa-github fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy;  Riley Shen 2022 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/post/"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/about/"
                        
                   title="">About Me</a></li>
        
            
            <li><a 
                   href="/contact/"
                        
                   title="">Contact</a></li>
        
        
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
<div class="post  animated fadeInDown ">
    <div class="post-content">
        
        <div class="post-title">
            <h2>spring learning code 4</h2>
            
            <div class="info">
                <em class="fas fa-calendar-day"></em>
                <span class="date">
                    Thu, Apr 16, 2020
                    </span>
                <em class="fas fa-stopwatch"></em>
                <span class="reading-time">7-minute read</span>
            </div>
            
        </div>

        <p>This is my learning note about how Spring core features like IoC, AOP works, with Code Examples .</p>
<h2 id="from-servlet-to-applicatoincontext">from Servlet to ApplicatoinContext</h2>
<h2 id="ioc">IoC</h2>
<ul>
<li>
<p><strong>Map</strong> 容器</p>
</li>
<li>
<p><strong>BeanFactory</strong> 工厂</p>
</li>
<li>
<p><strong>ApplicationContext</strong> 上下文：持有BeanFactory引用， 门面模式</p>
</li>
<li>
<p><strong>BeanDefinitionReader</strong>解析器：负责解析所有的配置文件</p>
</li>
<li>
<p><strong>BeanDefinition</strong>元信息，配置（保存各种配置信息）
xml, yml, annotation, properties</p>
</li>
<li>
<p><strong>Bean实例</strong>，反射实例化Object
原生Bean，代理Bean</p>
</li>
<li>
<p><strong>BeanWrapper</strong>包装器模式：缓存到了Ioc容器，缓存
持有Bean引用</p>
</li>
</ul>
<h2 id="ioc-顶层设计-listablebeanfactory为例">IOC 顶层设计， ListableBeanFactory为例</h2>
<p>用户通过 =&gt;  <strong>ApplicationContext</strong> =&gt; 调用 <strong>getBean()<strong>方法， 底层各种factory方法listable等，创建factory对象， 所以要调用</strong>BeanDefinitionReader</strong>, 读取bean配置文件，创建 <strong>BeanDefinition</strong> = &gt; 换存到容器里就是<strong>BeanWrapper</strong>对象， 所以getBean()实际拿到的就是<strong>BeanWrapper</strong>对象</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">init</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">new</span> <span class="n">ApplicationContext</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BeanDefinitionReader</span><span class="o">();</span>
        <span class="n">reader</span><span class="o">.</span><span class="na">loadBeanDefinitions</span><span class="o">();</span>

        <span class="n">factory</span><span class="o">.</span><span class="na">doRegistryBeanDefinition</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">beanDefinitionMap</span><span class="o">.</span><span class="na">put</span><span class="o">()</span>
        <span class="o">}</span>

        <span class="n">doLoadInstance</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">getBean</span><span class="o">()</span> <span class="c1">//循环调用
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">getBean</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">BeanDefinition</span> <span class="n">beanDefinition</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="na">beanDefinitionMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>

    <span class="n">Object</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">instantiateBean</span><span class="o">();</span>

    <span class="n">BeanWrapper</span> <span class="n">beanWrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BeanWrapper</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>

    <span class="n">factoryBeanInstanceCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beanWrapper</span><span class="o">);</span>

    <span class="n">populateBean</span><span class="o">();</span> <span class="c1">//依赖注入
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p><em><strong>1.1 the most basic bean container</strong></em>
define a simple bean container: BeanFactory, contains a map to store bean, owns registry and get Bean two methods.</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanFactory</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">beanMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerBean</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">bean</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">beanMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="n">Object</span> <span class="nf">getBean</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">beanMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleBeanContainerTest</span> <span class="o">{</span>

	<span class="nd">@Test</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGetBean</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
		<span class="n">BeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BeanFactory</span><span class="o">();</span>
		<span class="n">beanFactory</span><span class="o">.</span><span class="na">registerBean</span><span class="o">(</span><span class="s">&#34;helloService&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">HelloService</span><span class="o">());</span>
		<span class="n">HelloService</span> <span class="n">helloService</span> <span class="o">=</span> <span class="o">(</span><span class="n">HelloService</span><span class="o">)</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&#34;helloService&#34;</span><span class="o">);</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">helloService</span><span class="o">).</span><span class="na">isNotNull</span><span class="o">();</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">helloService</span><span class="o">.</span><span class="na">sayHello</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">class</span> <span class="nc">HelloService</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHello</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
			<span class="k">return</span> <span class="s">&#34;hello&#34;</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div><p><em><strong>BeanDefinition &amp; BeanDefinitionRegistry</strong></em>
<img src="https://github.com/DerekYRC/mini-spring/blob/main/assets/bean-definition-and-bean-definition-registry.png?raw=true" alt="p"></p>
<p><img src="F%EF%BC%9A/blog/themes/anatole/images" alt="image"></p>
<p>click here <a href="https://github.com/RileyCode-hash/SpringNotes/tree/BeanDefinition-BeanDefinitionRegistry/minSpring"  target="_blank" >code download</a></p>
<blockquote>
<p>&hellip;beans.factory.config.SingletonBeanRegistry.java</p>
</blockquote>
<blockquote>
<p>&hellip;beans.factory.config.BeanDefinition.java</p>
</blockquote>
<blockquote>
<p>&hellip;beans.factory.support.DefaultSingletonBeanRegistry.java</p>
</blockquote>
<blockquote>
<p>&hellip;beans.factory.BeanFactory.java</p>
</blockquote>
<blockquote>
<p>&hellip;beans.factory.support.AbstractAutowireCapableBeanFactory.java</p>
</blockquote>
<blockquote>
<p>&hellip;beans.factory.support.AbstractBeanFactory.java</p>
</blockquote>
<blockquote>
<p>&hellip;beans.factory.support.BeanDefinitionRegistry.java</p>
</blockquote>
<blockquote>
<p>&hellip;beans.factory.support.DefaultListableBeanFactory.java</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">org.springframework.beans</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanDefinitionAndBeanDefinitionRegistryTest</span> <span class="o">{</span>

	<span class="nd">@Test</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testBeanFactory</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
		<span class="n">DefaultListableBeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultListableBeanFactory</span><span class="o">();</span>
		<span class="n">BeanDefinition</span> <span class="n">beanDefinition</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BeanDefinition</span><span class="o">(</span><span class="n">HelloService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="n">beanFactory</span><span class="o">.</span><span class="na">registerBeanDefinition</span><span class="o">(</span><span class="s">&#34;helloService&#34;</span><span class="o">,</span> <span class="n">beanDefinition</span><span class="o">);</span>

		<span class="n">HelloService</span> <span class="n">helloService</span> <span class="o">=</span> <span class="o">(</span><span class="n">HelloService</span><span class="o">)</span> <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&#34;helloService&#34;</span><span class="o">);</span>
		<span class="n">helloService</span><span class="o">.</span><span class="na">sayHello</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HelloService</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHello</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
		<span class="k">return</span> <span class="s">&#34;hello&#34;</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>


</code></pre></div><p><em><strong>InstantiationStrategy</strong></em></p>
<p>now we instantiat bean by method : <code>beanClass.newInstance()</code> in <code>AbstractAutowireCapableBeanFactory.doCreateBean</code>. And this only used in <strong>NoArgsConstructo</strong></p>
<p>now create InstantiationStrategy interface with implemented methods
<img src="" alt="image"></p>
<ul>
<li>SimpleInstantiationStrategy: use bean construction</li>
<li>CglibSubclassingInstantiationStrategy，use CGLIB</li>
</ul>
<h1 id="基础java知识">基础java知识</h1>
<h2 id="servlet模板模式">servlet(模板模式)</h2>
<ul>
<li>HttpServlet已经实现了service方法：HttpServlet是一个抽象类</li>
</ul>
<p>一个类声明成抽象方法，一般有两个原因：
<em>有抽象方法</em> OR
<em>没有抽象方法，但是不希望被实例化</em></p>
<p>HttpServlet做成抽象类，仅仅是为了不让new</p>
<p>如何写一个Servet？</p>
<p>不用实现javax.servlet接口</p>
<p>不用继承GenericServlet抽象类</p>
<p>只需继承HttpServlet并重写doGet()/doPost()</p>
<p>父类把能写的逻辑都写完，把不确定的业务代码抽成一个方法，调用它。当子类重写该方法，整个业务代码就活了。这就是模板方法模式</p>
<p>父类：                                                               子类</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">service() {                                                        service() {
    doXxx(); //具体业务代码，但是父类无法知道子类具体业务逻辑，  &lt;= 继承  doXxx();
    //所以后抽象惩罚让子类重写                                         }
}

protected void doXxx() {                                   &lt;= 覆盖 void doXxx() {
    //空实现，或者默认实现                                          //具体实现
}                                                                   }
</code></pre></div><h2 id="servletcontext">ServletContext</h2>
<p>map，服务器会为每个应用创建一个ServletContext对象</p>
<p>ServletContext对象的作用是在整个Web应用的动态资源（Servlet/JSP）之间共享数据</p>
<p>这种用来装载共享数据的对象，在JavaWeb中共有4个，而且更习惯被成为“域对象”：</p>
<p>ServletContext域（Servlet间共享数据）</p>
<p>Session域（一次会话间共享数据，也可以理解为多次请求间共享数据）</p>
<p>Request域（同一次请求共享数据）</p>
<p>Page域（JSP页面内共享数据）</p>
<p>它们都可以看做是map，都有getAttribute()/setAttribute()方法。</p>
<h2 id="java泛型generics">Java泛型Generics</h2>
<ul>
<li>泛型类 <code>&lt;T&gt;</code>  Type Parameter</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">public class ArrayList&lt;T&gt; {
    private T[] array;
    private int size;
    public void add(T e) {...}
    public void remove(int index) {...}
    public T get(int index) {...}
}
</code></pre></div><ul>
<li>对变量类型进行抽取</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">public User getUser(T t){...}
</code></pre></div><ul>
<li>获取构造函数的参数</li>
</ul>
<p>获取到构造函数的对象之后，可以通过getParameterTypes()获取到构造函数的参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">Constructor constructors = birdClass.getConstructor(new Class[]{String.class});
            Class[] parameterTypes = constructors.getParameterTypes();
</code></pre></div><h2 id="反射">反射</h2>
<ul>
<li>JVM是如何构建一个实例的
A a = new A();</li>
</ul>
<blockquote>
<p>Step1: ClassLoader加载.class文件到内存（jvm内存;执行静态代码块和静态初始化语句</p>
</blockquote>
<blockquote>
<p>Step2: 执行new，申请一个内存空间</p>
</blockquote>
<blockquote>
<p>Step3:调用构造器，创建一个空白对象</p>
</blockquote>
<blockquote>
<p>step4：子类调用父类构造器</p>
</blockquote>
<blockquote>
<p>step5:构造器执行： 执行构造代码块和初始化语句； 构造器内容</p>
</blockquote>
<ul>
<li>Class</li>
</ul>
<p>Class类对象就相当于B超的探头，将一个类的方法、变量、接口、类名、类修饰符等信息告诉运行的程序。</p>
<ul>
<li>获取构造函数Constructor</li>
</ul>
<p>获取构造函数的方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">Class birdClass = Bird.class;
Constructor[] constructors = birdClass.getConstructors();
</code></pre></div><p>一个类会有多个构造函数，getConstructors()返回的是Constructor[]数组，包含了所有声明的用public修饰的构造函数。</p>
<p>如果你已经知道了某个构造的参数，可以通过下面的方法获取到回应的构造函数对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">public class Alunbar {
    public static void  main(String arts[]){

        Class birdClass = Bird.class;
        try{
            Constructor constructors = birdClass.getConstructor(new Class[]{String.class});
        }catch(NoSuchMethodException  e){

        }
    }

    private class Bird {
        public Bird(){

        }

        public Bird(String eat){

        }
    }
}
</code></pre></div><ul>
<li>类加载器</li>
</ul>
<p>loadClass()，告诉它需要加载的类名，它会帮你加载</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">    // 子类应该重写该方法
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
</code></pre></div><p>加载.class文件大致可以分为3个步骤：</p>
<p>检查是否已经加载，有就直接返回，避免重复加载
当前缓存中确实没有该类，那么遵循父优先加载机制，加载.class文件
上面两步都失败了，调用findClass()方法加载
需要注意的是，ClassLoader类本身是抽象类，而抽象类是无法通过new创建对象的。所以它的findClass()方法写的很随意，直接抛了异常，反正你无法通过ClassLoader对象调用。也就是说，父类ClassLoader中的findClass()方法根本不会去加载.class文件。</p>
<p>正确的做法是，子类重写覆盖findClass()，在里面写自定义的加载逻辑。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">@Override
public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
	try {
		/*自己另外写一个getClassData()
                  通过IO流从指定位置读取xxx.class文件得到字节数组*/
		byte[] datas = getClassData(name);
		if(datas == null) {
			throw new ClassNotFoundException(&#34;类没有找到：&#34; + name);
		}
		//调用类加载器本身的defineClass()方法，由字节码得到Class对象
		return defineClass(name, datas, 0, datas.length);
	} catch (IOException e) {
		e.printStackTrace();
		throw new ClassNotFoundException(&#34;类找不到：&#34; + name);
	}
}
</code></pre></div><p>defineClass()是ClassLoader定义的方法，目的是根据.class文件的字节数组byte[] b造出一个对应的Class对象。我们无法得知具体是如何实现的，因为最终它会调用一个native方法：</p>
<ul>
<li>反射API</li>
</ul>
<blockquote>
<p>创建实例</p>
</blockquote>
<p>clazz.newInstance()底层还是调用Contructor对象的newInstance()。所以，要想调用clazz.newInstance()，必须保证编写类的时候有个无参构造。</p>
<h2 id="为什么根据class对象获取method时需要传入方法名参数的class类型">为什么根据Class对象获取Method时，需要传入方法名+参数的Class类型？</h2>
<p>调用Class对象的getMethod()方法时，内部会循环遍历所有Method，然后根据方法名和参数类型匹配唯一的Method返回。</p>
<h2 id="调用methodinvokeobj-args时为什么要传入一个目标对象">调用method.invoke(obj, args);时为什么要传入一个目标对象？</h2>
<p>把Method理解为方法执行指令吧，它更像是一个方法执行器，必须告诉它要执行的对象（数据）。</p>
<blockquote>
<p>反射调用方法</p>
</blockquote>
<h2 id="java-动态代理">Java 动态代理</h2>
<ul>
<li>问题： 原有代码：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">public class Calculator {

	//加
	public int add(int a, int b) {
		int result = a + b;
		return result;
	}

	//减
	public int subtract(int a, int b) {
		int result = a - b;
		return result;
	}

	//乘法、除法...
}

</code></pre></div><p>现有一个需求：在每个方法执行前后打印日志.</p>
<p>直接修改</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">
public class Calculator {

	//加
	public int add(int a, int b) {
		System.out.println(&#34;add方法开始...&#34;);
		int result = a + b;
		System.out.println(&#34;add方法结束...&#34;);
		return result;
	}

	//减
	public int subtract(int a, int b) {
		System.out.println(&#34;subtract方法开始...&#34;);
		int result = a - b;
		System.out.println(&#34;subtract方法结束...&#34;);
		return result;
	}

	//乘法、除法...
}

</code></pre></div><p>上面的方案是有问题的：</p>
<p>直接修改源程序，不符合开闭原则。应该对扩展开放，对修改关闭
如果Calculator有几十个、上百个方法，修改量太大
存在重复代码（都是在核心代码前后打印日志）
日志打印硬编码在代理类中，不利于后期维护：比如你花了一上午终于写完了，组长告诉你这个功能取消，于是你又要打开Calculator花十分钟删除日志打印的代码！</p>
<ul>
<li>静态代理,通过代理访问目标对象</li>
</ul>
<p>静态代理的实现比较简单：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加前拦截，后拦截等所需的业务功能。</p>
<ul>
<li>将Calculator抽取为接口</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">
/**
 * 目标对象实现类，实现Calculator接口
 */
public class CalculatorImpl implements Calculator {

	//加
	public int add(int a, int b) {
		int result = a + b;
		return result;
	}

	//减
	public int subtract(int a, int b) {
		int result = a - b;
		return result;
	}

	//乘法、除法...
}

</code></pre></div><ul>
<li>创建代理类CalculatorProxy实现Calculator</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">
/**
 * 代理对象实现类，实现Calculator接口
 */
public class CalculatorProxy implements Calculator {
        //代理对象内部维护一个目标对象引用
	private Calculator target;
        
        //构造方法，传入目标对象
	public CalculatorProxy(Calculator target) {
		this.target = target;
	}

        //调用目标对象的add，并在前后打印日志
	@Override
	public int add(int a, int b) {
		System.out.println(&#34;add方法开始...&#34;);
		int result = target.add(a, b);
		System.out.println(&#34;add方法结束...&#34;);
		return result;
	}

        //调用目标对象的subtract，并在前后打印日志
	@Override
	public int subtract(int a, int b) {
		System.out.println(&#34;subtract方法开始...&#34;);
		int result = target.subtract(a, b);
		System.out.println(&#34;subtract方法结束...&#34;);
		return result;
	}

	//乘法、除法...
}

</code></pre></div><ul>
<li>使用代理对象完成加减乘除，并且打印日志</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">
public class Test {
	public static void main(String[] args) {
		//把目标对象通过构造器塞入代理对象
		Calculator calculator = new CalculatorProxy(new CalculatorImpl());
		//代理对象调用目标对象方法完成计算，并在前后打印日志
		calculator.add(1, 2);
		calculator.subtract(2, 1);
	}
}

</code></pre></div><p>没解决重复代码，如果有很多类，没解决修改量太大的问题，
<strong>所以我们要代理的不是代理类，而是代理对象，根据接口自动生成代理对象</strong></p>
<ul>
<li>动态代理</li>
</ul>
<p>Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。</p>
<ul>
<li>使用代理对象完成加减乘除，并且打印日志</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">
public class ProxyTest {
	public static void main(String[] args) throws Throwable {
		//Calculator的类加载器
		Class calculatorProxyClazz = Proxy.getProxyClass(Calculator.class.getClassLoader(), Calculator.class);
		//得到有参构造器
        Constructor constructor =  calculatorProxyClazz.getConstructor(InvocationHandler.class);
        //反射创建代理实例
        Calculator CalculatorProxyImpl = (Calculator)constructor.newInstance(new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method, method, Object[] args) throws Exception {
                //手动new一个目标对象
                CalculatorImpl calculatorImpl = new CalculatorImpl();
                //反射执行目标对象的方法
                Object result = method.invoke(calculatorImpl, args);
                //返回目标对象执行结果
                return result;
            }
        })
		CalculatorProxyImpl.add(1, 2);
		
	}
}

</code></pre></div><p>代理对象改变，invoke方法要改，所以把目标对象当参数传进来</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">
public class ProxyTest {
	public static void main(String[] args) throws Throwable {
        //传入目标对象
        CalculatorImpl target = new CalculatorImpl();
        //根据它实现的接口生成代理对象， 代理对象调用目标对象方法
		Calculator calculatorProxy = (Calculator)getProxy(target);
        calculatorProxy.add(1, 2);
        calculatorProxy.substract(2, 1);
    }

    private static Object getProxy(final Object target) throws Exception {
		Class ProxyClazz = Proxy.getProxyClass(target.getclass().getClassLoader(), target.getclass().getInterfaces());
		//得到有参构造器
        Constructor constructor =  ProxyClazz.getConstructor(InvocationHandler.class);
        //反射创建代理实例
        Object proxy = constructor.newInstance(new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method, method, Object[] args) throws Exception {
                System.out.println(method.getName() + &#34;方法开始执行。。&#34;);
                Object result = method.invoke(target, args);
                //反射执行目标对象的方法
                
                return result;
            }
        });
		return proxy;
		
	}
}

</code></pre></div><p>无论现在系统有多少类，只要你把实例传进来，getProxy()都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p>
<p>不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">
public class ProxyTest {
	public static void main(String[] args) throws Throwable {
        //传入目标对象
        CalculatorImpl target = new CalculatorImpl();
        //根据它实现的接口生成代理对象， 代理对象调用目标对象方法
		Calculator calculatorProxy = (Calculator)getProxy(target);
        calculatorProxy.add(1, 2);
        calculatorProxy.substract(2, 1);
    }

    private static Object getProxy(final Object target) throws Exception {
		Object proxy = Proxy.newProxyInstance(target.getclass().getClassLoader(), target.getclass().getInterfaces(),
		new InvocationHandler() {
            
            public Object invoke(Object proxy, Method, method, Object[] args) throws Exception {
                System.out.println(method.getName() + &#34;方法开始执行。。&#34;);
                Object result = method.invoke(target, args);
                //反射执行目标对象的方法
                
                return result;
            }
        }
        );
		return proxy;
		
	}
}

</code></pre></div><h1 id="spring-di">Spring DI</h1>
<p>组合复合原则（怎么给对象自动赋值，循环依赖注入）</p>
<h1 id="spring-mvc">Spring MVC</h1>
<p>委派，策略，解释器原则（用户输入URL怎么样和java代码关联）</p>
<h1 id="spring-aop">Spring AOP</h1>
<p>责任，动态代理</p>
<p>我们需要一个通知类（TransactionManager）执行事务，一个代理工厂帮助生成代理对象，然后利用动态代理将事务代码织入代理对象的各个方法中。</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">UserService {
    public void test() {
        //开启事务
        userDao.add();
    }
}
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">BrandService {
    public void test() {
        //开启事务
        brandDao.add();
    }
}
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">CategoryService {
    public void test() {
        //开启事务
        categoryDao.add();
    }
}
</code></pre></div><p>希望最终达到的效果是，我加了个@MyTransactional后，代理工厂给我返回一个代理对象：</p>
<p>UserService &ndash;》 入参  |代理工厂| 出参 &ndash;》 UserServiceProxy</p>
<p>细节分析：</p>
<p>UserServiceProxy.test() &ndash;&gt; //+1 +8</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">|代理工厂| 
  代理对象 {
    //1.开启事务
    txManager.beginTransaction(); //+2
    //2.执行事务
    rtValue = method.invoke(target, args) --&gt; 调用代理对象同名方法+3 +5
       //3.提交事务
    txManager.commit(); //+6
    //3.返回结果
    return rtValue; //+7
}
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">UserService {
    public void test() { //+4
        //开启事务
        userDao.add();
    }
}
</code></pre></div><p>代理对象方法 = 事务 + 目标对象方法。</p>
<p>事务操作，必须使用同一个Connection对象。如何保证？第一次从数据源获取Connection对象并开启事务后，将它存入当前线程的ThreadLocal中，等到了DAO层，还是从ThreadLocal中取，这样就能保证开启事务和操作数据库使用的Connection对象是同一个。</p>
<p>开启事务后，Controller并不是直接调用Service，而是Spring提供的代理对象</p>
<p>Service和Dao关系也是i如此</p>
<h1 id="aop事务具体代码实现">AOP事务具体代码实现</h1>
<h2 id="connectionutils工具类">ConnectionUtils工具类</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">com</span><span class="p">.</span><span class="nx">demo</span><span class="p">.</span><span class="nx">myaopframework</span><span class="p">.</span><span class="nx">utils</span><span class="p">;</span>

<span class="kn">import</span> <span class="nx">org</span><span class="p">.</span><span class="nx">apache</span><span class="p">.</span><span class="nx">commons</span><span class="p">.</span><span class="nx">dbcp</span><span class="p">.</span><span class="nx">BasicDataSource</span><span class="p">;</span>

<span class="kn">import</span> <span class="nx">java</span><span class="p">.</span><span class="nx">sql</span><span class="p">.</span><span class="nx">Connection</span><span class="p">;</span>

<span class="cm">/**
</span><span class="cm"> * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定
</span><span class="cm"> */</span>
<span class="nx">public</span> <span class="nx">class</span> <span class="nx">ConnectionUtils</span> <span class="p">{</span>

    <span class="nx">private</span> <span class="nx">ThreadLocal</span><span class="p">&lt;</span><span class="nx">Connection</span><span class="p">&gt;</span> <span class="nx">tl</span> <span class="p">=</span> <span class="nx">new</span> <span class="nx">ThreadLocal</span><span class="p">&lt;</span><span class="nx">Connection</span><span class="p">&gt;();</span>

    <span class="nx">private</span> <span class="nx">static</span> <span class="nx">BasicDataSource</span> <span class="nx">dataSource</span> <span class="p">=</span> <span class="nx">new</span> <span class="nf">BasicDataSource</span><span class="p">();</span>

    <span class="c1">//静态代码块,设置连接数据库的参数
</span><span class="c1"></span>    <span class="nx">static</span><span class="p">{</span>
        <span class="nx">dataSource</span><span class="p">.</span><span class="nf">setDriverClassName</span><span class="p">(</span><span class="s">&#34;com.mysql.jdbc.Driver&#34;</span><span class="p">);</span>
        <span class="nx">dataSource</span><span class="p">.</span><span class="nf">setUrl</span><span class="p">(</span><span class="s">&#34;jdbc:mysql://localhost:3306/test&#34;</span><span class="p">);</span>
        <span class="nx">dataSource</span><span class="p">.</span><span class="nf">setUsername</span><span class="p">(</span><span class="s">&#34;root&#34;</span><span class="p">);</span>
        <span class="nx">dataSource</span><span class="p">.</span><span class="nf">setPassword</span><span class="p">(</span><span class="s">&#34;123456&#34;</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/**
</span><span class="cm">     * 获取当前线程上的连接
</span><span class="cm">     * @return
</span><span class="cm">     */</span>
    <span class="nx">public</span> <span class="nx">Connection</span> <span class="nf">getThreadConnection</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">try</span><span class="p">{</span>
            <span class="c1">//1.先从ThreadLocal上获取
</span><span class="c1"></span>            <span class="nx">Connection</span> <span class="nx">conn</span> <span class="p">=</span> <span class="nx">tl</span><span class="p">.</span><span class="nf">get</span><span class="p">();</span>
            <span class="c1">//2.判断当前线程上是否有连接
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="nx">conn</span> <span class="o">==</span> <span class="nx">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//3.从数据源中获取一个连接，并且存入ThreadLocal中
</span><span class="c1"></span>                <span class="nx">conn</span> <span class="p">=</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nf">getConnection</span><span class="p">();</span>
                <span class="nx">tl</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">conn</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">//4.返回当前线程上的连接
</span><span class="c1"></span>            <span class="k">return</span> <span class="nx">conn</span><span class="p">;</span>
        <span class="p">}</span><span class="nf">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nx">e</span><span class="p">){</span>
            <span class="nx">throw</span> <span class="nx">new</span> <span class="nf">RuntimeException</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * 把连接和线程解绑
</span><span class="cm">     */</span>
    <span class="nx">public</span> <span class="nx">void</span> <span class="nf">removeConnection</span><span class="p">(){</span>
        <span class="nx">tl</span><span class="p">.</span><span class="nf">remove</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="aop通知事务管理器">AOP通知（事务管理器）</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">com</span><span class="p">.</span><span class="nx">demo</span><span class="p">.</span><span class="nx">myaopframework</span><span class="p">.</span><span class="nx">utils</span><span class="p">;</span>

<span class="cm">/**
</span><span class="cm"> * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接
</span><span class="cm"> */</span>
<span class="nx">public</span> <span class="nx">class</span> <span class="nx">TransactionManager</span> <span class="p">{</span>

    <span class="nx">private</span> <span class="nx">ConnectionUtils</span> <span class="nx">connectionUtils</span><span class="p">;</span>

    <span class="nx">public</span> <span class="nx">void</span> <span class="nf">setConnectionUtils</span><span class="p">(</span><span class="nx">ConnectionUtils</span> <span class="nx">connectionUtils</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">this</span><span class="p">.</span><span class="nx">connectionUtils</span> <span class="p">=</span> <span class="nx">connectionUtils</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * 开启事务
</span><span class="cm">     */</span>
    <span class="nx">public</span>  <span class="nx">void</span> <span class="nf">beginTransaction</span><span class="p">(){</span>
        <span class="nx">try</span> <span class="p">{</span>
            <span class="nx">connectionUtils</span><span class="p">.</span><span class="nf">getThreadConnection</span><span class="p">().</span><span class="nf">setAutoCommit</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
        <span class="p">}</span><span class="nf">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nx">e</span><span class="p">){</span>
            <span class="nx">e</span><span class="p">.</span><span class="nf">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * 提交事务
</span><span class="cm">     */</span>
    <span class="nx">public</span>  <span class="nx">void</span> <span class="nf">commit</span><span class="p">(){</span>
        <span class="nx">try</span> <span class="p">{</span>
            <span class="nx">connectionUtils</span><span class="p">.</span><span class="nf">getThreadConnection</span><span class="p">().</span><span class="nf">commit</span><span class="p">();</span>
        <span class="p">}</span><span class="nf">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nx">e</span><span class="p">){</span>
            <span class="nx">e</span><span class="p">.</span><span class="nf">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * 回滚事务
</span><span class="cm">     */</span>
    <span class="nx">public</span>  <span class="nx">void</span> <span class="nf">rollback</span><span class="p">(){</span>
        <span class="nx">try</span> <span class="p">{</span>
            <span class="nx">connectionUtils</span><span class="p">.</span><span class="nf">getThreadConnection</span><span class="p">().</span><span class="nf">rollback</span><span class="p">();</span>
        <span class="p">}</span><span class="nf">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nx">e</span><span class="p">){</span>
            <span class="nx">e</span><span class="p">.</span><span class="nf">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/**
</span><span class="cm">     * 释放连接
</span><span class="cm">     */</span>
    <span class="nx">public</span>  <span class="nx">void</span> <span class="nf">release</span><span class="p">(){</span>
        <span class="nx">try</span> <span class="p">{</span>
            <span class="nx">connectionUtils</span><span class="p">.</span><span class="nf">getThreadConnection</span><span class="p">().</span><span class="nb">close</span><span class="p">();</span><span class="c1">//还回连接池中
</span><span class="c1"></span>            <span class="nx">connectionUtils</span><span class="p">.</span><span class="nf">removeConnection</span><span class="p">();</span>
        <span class="p">}</span><span class="nf">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nx">e</span><span class="p">){</span>
            <span class="nx">e</span><span class="p">.</span><span class="nf">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="自定义注解">自定义注解</h2>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTransactional {
}
</code></pre></div><h2 id="service">Service</h2>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">public interface UserService {
	void getUser();
}

 
public class UserServiceImpl implements UserService {
	@Override
	public void getUser() {
		System.out.println(&#34;service执行...&#34;);
	}
}
</code></pre></div><h2 id="实例工厂">实例工厂</h2>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">public class BeanFactory {

	public Object getBean(String name) throws Exception {
		//得到目标类的Class对象
		Class&lt;?&gt; clazz = Class.forName(name);
		//得到目标对象
		Object bean = clazz.newInstance();
		//得到目标类上的@MyTransactional注解
		MyTransactional myTransactional = clazz.getAnnotation(MyTransactional.class);
		//如果打了@MyTransactional注解，返回代理对象，否则返回目标对象
		if (null != myTransactional) {
			ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();
			TransactionManager txManager = new TransactionManager();
			txManager.setConnectionUtils(new ConnectionUtils());
			//装配通知和目标对象
			proxyFactoryBean.setTxManager(txManager);
			proxyFactoryBean.setTarget(bean);
			Object proxyBean = proxyFactoryBean.getProxy();
			//返回代理对象
			return proxyBean;
		}
		//返回目标对象
		return bean;
	}
}
</code></pre></div><h2 id="代理工厂">代理工厂</h2>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">public class ProxyFactoryBean {
	//通知
	private TransactionManager txManager;
	//目标对象
	private Object target;

	public void setTxManager(TransactionManager txManager) {
		this.txManager = txManager;
	}

	public void setTarget(Object target) {
		this.target = target;
	}

	//传入目标对象target，为它装配好通知，返回代理对象
	public Object getProxy() {
		Object proxy = Proxy.newProxyInstance(
				target.getClass().getClassLoader(),/*1.类加载器*/
				target.getClass().getInterfaces(), /*2.目标对象实现的接口*/
				new InvocationHandler() {/*3.InvocationHandler*/
					@Override
					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
						try {
							//1.开启事务
							txManager.beginTransaction();
							//2.执行操作
							Object retVal = method.invoke(target, args);
							//3.提交事务
							txManager.commit();
							//4.返回结果
							return retVal;
						} catch (Exception e) {
							//5.回滚事务
							txManager.rollback();
							throw new RuntimeException(e);
						} finally {
							//6.释放连接
							txManager.release();
						}

					}
				}
		);
		return proxy;
	}

}
</code></pre></div><p>AOPTest,</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">BeanFactory beanFactory = new BeanFactory();
try {
    Object bean = beanFactory.getBean(&#34;com.demo.mya.service.UserServiceImpl&#34;);
    Sout(bean.getClass().getName());
}
</code></pre></div><blockquote>
<p>com.demo.mya.service.UserServiceImpl</p>
</blockquote>
<p>给UserServiceImpl添加@MyTransactional注解，得到代理对象：</p>
<blockquote>
<p>com.sun.proxy.$Proxy2</p>
</blockquote>
<hr>
<h4 id="ok-its-time-for-spring1-hahahugoshortcode-s0-hbhb">Ok, It&rsquo;s time for <a href="https://rileyshen.github.io/post/spring1/" >spring1 </a></h4>
<h4 id="ok-its-time-for-spring2-hahahugoshortcode-s1-hbhb">Ok, It&rsquo;s time for <a href="https://rileyshen.github.io/post/spring2/" >spring2 </a></h4>
<h4 id="ok-its-time-for-spring-mvchahahugoshortcode-s2-hbhb">Ok, It&rsquo;s time for <a href="https://rileyshen.github.io/post/springmvc/" >spring mvc</a></h4>
<p><a id="markdown-ok%2C-it's-time-for-spring-mvc" name="ok%2C-it's-time-for-spring-mvc"></a></p></div>
    <div class="post-footer">
        <div class="info">
            
            <span class="separator"><a class="tag" href="/tags/crud/">CRUD</a><a class="tag" href="/tags/ioc/">IOC</a><a class="tag" href="/tags/aop/">AOP</a><a class="tag" href="/tags/spring5/">Spring5</a></span>
        </div>
    </div>

    
</div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js"
        integrity="sha256-g8sd1f6o1C2H0eYBoH&#43;qcwia0O&#43;cz&#43;Xa9gQSievMTkY="
        crossorigin="anonymous"></script>
<script async defer src="//latest.js"></script>
<noscript><img src="//noscript.gif" alt=""/></noscript>

</body>

</html>
