<!DOCTYPE html>
<html  dir="ltr" lang="en" data-theme=""><head>
    <title> Riley Shen | about Dynamic Programming </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.83.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description"
        content="java inteview algorithm">
    <meta name="google-site-verification" content="Nac1UrFTdr1E1F48JLe7XQhIbKn2_WtF4VnJI8KOtew" />
    

    
    
    
    <link rel="stylesheet" href="/css/main.min.a7c9793b97840076bef76d2743ee1c90b13bd21c18674076a0cccd5dd54c723b.css" integrity="sha256-p8l5O5eEAHa&#43;920nQ&#43;4ckLE70hwYZ0B2oMzNXdVMcjs="
        crossorigin="anonymous" type="text/css">
    
    
    <link rel="stylesheet" href="/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css"
        integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS&#43;yuWSR4=" crossorigin="anonymous" type="text/css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
        integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
        crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">

    <link rel="canonical" href="/post/dp/">

    <link rel="preconnect" href="https://fonts.gstatic.com">



    
    
    
    
    <script type="text/javascript" src="/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js"
        integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ=" crossorigin="anonymous"></script>


    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://rileyshen.github.io/images/site-feature-image.png"/>

<meta name="twitter:title" content="about Dynamic Programming"/>
<meta name="twitter:description" content="java inteview algorithm"/>


    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,300;0,400;0,500;0,600;0,700;1,500;1,600;1,700&display=swap"
        rel="stylesheet">

</head><body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="/images/profileS.jpg" alt="profile picture">
            <h3 title=""><a href="/">I&#39;m Riley Shen</a></h3>
            <div class="description">
                <p><br>Riley likes to push her limits <br>and always keep learning new things. <br>She shares her weekly learnings <br>because "if you can't explain it simply,<br>it means you didn't understand it well enough".<br></p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="mailto:ripple.shen31@gmail.com" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://github.com/rileyshen" rel="me" aria-label="GitHub">
                    <i class="fab fa-github fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy;  Riley Shen 2022 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/post/"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/about/"
                        
                   title="">About Me</a></li>
        
            
            <li><a 
                   href="/contact/"
                        
                   title="">Contact</a></li>
        
        
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
<div class="post  animated fadeInDown ">
    <div class="post-content">
        
        <div class="post-title">
            <h2>about Dynamic Programming</h2>
            
            <div class="info">
                <em class="fas fa-calendar-day"></em>
                <span class="date">
                    Wed, Sep 1, 2021
                    </span>
                <em class="fas fa-stopwatch"></em>
                <span class="reading-time">42-minute read</span>
            </div>
            
        </div>

        <p>about Dynamic Programming learing note</p>
<h2 id="steps-to-solve-a-dynamic-programming-problems">steps to solve a dynamic programming problems</h2>
<h3 id="sp1-dp-table-and-index-meaning">sp1. dp table and index meaning</h3>
<p><a id="markdown-sp1.-dp-table-and-index-meaning" name="sp1.-dp-table-and-index-meaning"></a></p>
<h3 id="sp2-recurrence-formula">sp2. recurrence formula</h3>
<p><a id="markdown-sp2.-recurrence-formula" name="sp2.-recurrence-formula"></a></p>
<h3 id="sp3-initial-values">sp3. initial values</h3>
<p><a id="markdown-sp3.-initial-values" name="sp3.-initial-values"></a></p>
<h3 id="sp4-literacy-directions">sp4. literacy directions</h3>
<p><a id="markdown-sp4.-literacy-directions" name="sp4.-literacy-directions"></a></p>
<h3 id="sp5-cases">sp5. cases</h3>
<p><a id="markdown-sp5.-cases" name="sp5.-cases"></a></p>
<h4 id="q1-climbing-stairs">Q.1: Climbing Stairs</h4>
<p><a id="markdown-q.1%3A-climbing-stairs" name="q.1%3A-climbing-stairs"></a> 
<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are climbing a staircase. It takes n steps to reach the top.

Each <span class="nb">time</span> you can either climb <span class="m">1</span> or <span class="m">2</span> steps. In how many distinct ways can you climb to the top?
</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]: reach to the ith stairs, have dp[i] methods</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[i - 1], reach to the i - 1 th stairs, take one step = dp[i]</p>
</blockquote>
<blockquote>
<p>dp[i - 2], reach to the i - 2 th stairs, take two steps at onece = dp[i]</p>
</blockquote>
<blockquote>
<p>dp[i] = dp[i - 1] + dp[i -2]</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[1] = 1, dp[2] = 2, //here dp[0] has no meaning</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>front to back</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>n = 5</p>
</blockquote>
<blockquote>
<p>i :   1   2   3   4   5<br>
dp[i]: 1   2   3   5   8</p>
</blockquote>
<h4 id="q2-min-cost-climbing-stairs">Q.2: Min Cost Climbing Stairs</h4>
<p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an integer array cost where cost<span class="o">[</span>i<span class="o">]</span> is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.
</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]: reach to the ith stairs, have the least costs dp[i]</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[i - 1] or dp[i - 2] 2 choices</p>
</blockquote>
<blockquote>
<p>dp[i] = min(dp[i - 1],  dp[i -2]) + cost[i];</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = cost[0], dp[1] =  cost[1]</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>front to back</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>cpst = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</p>
</blockquote>
<blockquote>
<p>i :   0   1    2   3   4   5   6   7   8   9<br>
dp[i]: 1   100  2   3   3  103  4   5  104   6</p>
</blockquote>
<h4 id="q3-unique-paths">Q.3: Unique Paths</h4>
<p><a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">A robot is located at the top-left corner of a m x n grid <span class="o">(</span>marked <span class="s1">&#39;Start&#39;</span> in the diagram below<span class="o">)</span>.

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid <span class="o">(</span>marked <span class="s1">&#39;Finish&#39;</span> in the diagram below<span class="o">)</span>.

How many possible unique paths are there?

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[m][n]: reach to the (i, j) stairs, have dp[m][n] choices</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[m][n] = dp[m - 1][n] + dp[m][n -1]</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = 1; from(0, 0) to (i, 0) has only one path; for (int i = 0; i &lt; m; i++)&gt;)</p>
</blockquote>
<blockquote>
<blockquote>
<p>dp[0][j] = 1; from(0, 0) to (0, j) has only one path;</p>
</blockquote>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>left to right</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>m = 3, n = 7,</p>
</blockquote>
<blockquote>
<p>:   1   1    1   1   1   1   1</p>
</blockquote>
<blockquote>
<p>:   1   2    3   4   5   6   7</p>
</blockquote>
<blockquote>
<p>:   1   3    6   10  15  21  28</p>
</blockquote>
<p>O(M*N),
O(N)</p>
<p><strong>reducing space complexity</strong></p>
<blockquote>
<p>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</p>
</blockquote>
<blockquote>
<p>dp[j] = dp[j] + dp[j - 1]</p>
</blockquote>
<p>O(M*N),
O(N)</p>
<div class="highlight"><pre class="chroma"><code class="language-JAVA" data-lang="JAVA"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//一维空间，其大小为 n
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//等式右边的 dp[j]是上一次计算后的，加上左边的dp[j-1]即为当前结果
</span><span class="c1"></span>                <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
    <span class="o">}</span>   
<span class="o">}</span>

</code></pre></div><h4 id="q4unique-paths-ii">Q.4:Unique Paths II</h4>
<p><a id="markdown-q.4%3Aunique-paths-ii" name="q.4%3Aunique-paths-ii"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">A robot is located at the top-left corner of a m x n grid <span class="o">(</span>marked <span class="s1">&#39;Start&#39;</span> in the diagram below<span class="o">)</span>.

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid <span class="o">(</span>marked <span class="s1">&#39;Finish&#39;</span> in the diagram below<span class="o">)</span>.

Now consider <span class="k">if</span> some obstacles are added to the grids. How many unique paths would there be?

An obstacle and space is marked as <span class="m">1</span> and <span class="m">0</span> respectively in the grid.
</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[m][n]: reach to the (i, j) stairs, have dp[m][n] choices</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>if (obstacleGrid[i][j] == 0) {
dp[i][j] = dp[i - 1][j] + dp[i][j -1]
}</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = 1; from(0, 0) to (i, 0) has only one path; for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++)&gt;)</p>
</blockquote>
<blockquote>
<blockquote>
<p>dp[0][j] = 1; from(0, 0) to (0, j) has only one path; for (int i = 0; i &lt; n &amp;&amp; obstacleGrid[0][i] == 0; i++)</p>
</blockquote>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>left to right</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>m = 3, n = 7,</p>
</blockquote>
<blockquote>
<p>:   1   1    1</p>
</blockquote>
<blockquote>
<p>:   1   0    1</p>
</blockquote>
<blockquote>
<p>:   1   1    2</p>
</blockquote>
<figure><img src="/images/dp1.png"
         alt="image"/><figcaption>
            <h4>Unique Paths II</h4>
        </figcaption>
</figure>

<h4 id="q5integer-break">Q.5:Integer Break</h4>
<p><a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an integer n, <span class="nb">break</span> it into the sum of k positive integers, where k &gt;<span class="o">=</span> 2, and maximize the product of those integers.

Return the maximum product you can get.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]: number i, get maximize result dp[i]</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>j * (i -j)</p>
</blockquote>
<blockquote>
<p>j * dp[i - j]</p>
</blockquote>
<p>dp[i] = max(dp[i], max((i - j) * j, dp[i - j]* j));</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[2] = 1</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>front to back</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>n = 10</p>
</blockquote>
<blockquote>
<p>i     :   2   3   4   5   6   7   8   9   10</p>
</blockquote>
<blockquote>
<p>dp[i] :   1   2   4   6</p>
</blockquote>
<h4 id="q6backpack">Q.6:BackPack</h4>
<p><a id="markdown-q.6%3Abackpack" name="q.6%3Abackpack"></a></p>
<p>return the max value of the backpack</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">maxweight</span> <span class="o">=</span> <span class="m">4</span>

items:    weight   value
item0:       <span class="m">1</span>      <span class="m">15</span>
item1:       <span class="m">3</span>      <span class="m">20</span>
item2:       <span class="m">4</span>      <span class="m">30</span>
</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i][j]: [0-i]items, put in j weight backpack, return a max value</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>no more item: dp[i][j] = dp[i -1][j]</p>
</blockquote>
<blockquote>
<p>add item i: dp[i][j] = dp[i -1][j - weight[i]] + value[i]</p>
</blockquote>
<p>dp[i] = max(dp[i -1][j], dp[i - 1][j - weight[i] + value[i]]);</p>
<ul>
<li><em><strong>sp3. initial values</strong></em> 
backpack weight: j
dp[i][j]</li>
</ul>
<p>if j = 0, and j &lt; weight[0], dp[i][0] = 0, because no items can put in the backpack
if i = 0, jfor (int j = weight[0]; j &lt;= bagWeight; j++) ;  dp[0][j] = value[0];</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">        <span class="m">0</span>   <span class="m">1</span>   <span class="m">2</span>   <span class="m">3</span>   <span class="m">4</span>   
item0:  <span class="m">0</span>   <span class="m">15</span>  <span class="m">15</span>  <span class="m">15</span>  <span class="m">15</span>       
item1:  <span class="m">0</span>    
item2:  <span class="m">0</span>   
</code></pre></div><ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>front to back</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">
<span class="nv">maxweight</span> <span class="o">=</span> <span class="m">4</span>

items:    weight   value
item0:       <span class="m">1</span>      <span class="m">15</span>
item1:       <span class="m">3</span>      <span class="m">20</span>
item2:       <span class="m">4</span>      <span class="m">30</span>


        <span class="m">0</span>   <span class="m">1</span>   <span class="m">2</span>   <span class="m">3</span>   <span class="m">4</span>   
item0:  <span class="m">0</span>   <span class="m">15</span>  <span class="m">15</span>  <span class="m">15</span>  <span class="m">15</span>       
item1:  <span class="m">0</span>   <span class="m">15</span>  <span class="m">15</span>  <span class="m">20</span>  <span class="m">35</span>   
item2:  <span class="m">0</span>   <span class="m">15</span>  <span class="m">15</span>  <span class="m">20</span>  <span class="m">35</span> 
</code></pre></div><p>return dp[2][4]</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">weight</span> <span class="o">=</span> <span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">value</span> <span class="o">=</span> <span class="o">{</span><span class="n">15</span><span class="o">,</span> <span class="n">20</span><span class="o">,</span> <span class="n">30</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">bagSize</span> <span class="o">=</span> <span class="n">4</span><span class="o">;</span>
        <span class="n">testWeightBagProblem</span><span class="o">(</span><span class="n">weight</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">bagSize</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testWeightBagProblem</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">weight</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bagSize</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">wLen</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">value0</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="c1">//定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">wLen</span> <span class="o">+</span> <span class="n">1</span><span class="o">][</span><span class="n">bagSize</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
        <span class="c1">//初始化：背包容量为0时，能获得的价值都为0
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">wLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">value0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//遍历顺序：先遍历物品，再遍历背包容量
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">wLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">bagSize</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]]</span> <span class="o">+</span> <span class="n">value</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//打印dp数组
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">wLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">bagSize</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="s">&#34; &#34;</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;\n&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><p><strong>reducing space complexity</strong></p>
<p>dp[j]为 容量为 j 的背包所背的最大价值，那么如何推导 dp[j]呢？</p>
<p>dp[j]可以通过 dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为 j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品 i 重量 的背包 加上 物品 i 的价值。（也就是容量为 j 的背包，放入物品 i 了之后的价值即：dp[j]）</p>
<p>此时 dp[j]有两个选择，一个是取自己 dp[j] 相当于 二维 dp 数组中的 dp[i-1][j]，即不放物品 i，一个是取 dp[j - weight[i]] + value[i]，即放物品 i，指定是取最大的，毕竟是求最大价值，</p>
<blockquote>
<p>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">weight</span> <span class="o">=</span> <span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">value</span> <span class="o">=</span> <span class="o">{</span><span class="n">15</span><span class="o">,</span> <span class="n">20</span><span class="o">,</span> <span class="n">30</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">bagSize</span> <span class="o">=</span> <span class="n">4</span><span class="o">;</span>
        <span class="n">testWeightBagProblem</span><span class="o">(</span><span class="n">weight</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">bagSize</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testWeightBagProblem</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">weight</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bagSize</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">wLen</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">value0</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="c1">//定义dp数组：dp[j]表示背包容量为j时，获得的最大价值
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">bagSize</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
       
        <span class="c1">//遍历顺序：先遍历物品，再遍历背包容量
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">wLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">bagSize</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">weight</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">j</span><span class="o">--){</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">+</span> <span class="n">value</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//打印dp数组
</span><span class="c1"></span>   
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">bagWeight</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="s">&#34; &#34;</span><span class="o">);</span>
            <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><hr>
<h4 id="q7partition-equal-subset-sum">Q.7:Partition Equal Subset Sum</h4>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given a non-empty array nums containing only positive integers, find <span class="k">if</span> the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">This is a Knapsack problem, 

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i][j]: whether we can sum to j using first i numbers</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[j] = max(dp[j],  dp[j - nums[i]] + nums[i]);</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = 0</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>for (int i = 0; i &lt; nums.length(); i++) {
for (int j = target; j &gt;= nums[i]; j&ndash;) {
dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
}
}</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[1, 5, 11, 5], target = 11</p>
</blockquote>
<blockquote>
<p>nums[0] - 1             {0, 1}</p>
</blockquote>
<blockquote>
<p>nums[1] - 5              {0, 1, 5, 6}</p>
</blockquote>
<blockquote>
<p>nums[2] - 11             {0, 1, 5, 6, 11}</p>
</blockquote>
<blockquote>
<p>nums[3] - 5              {0, 1, 5, 6, 11, 10}</p>
</blockquote>
<hr>
<p>dp table:(front to back, 2d matrix)</p>
<figure><img src="/images/dp2.png"
         alt="image"/><figcaption>
            <h4>Partition Equal Subset Sum </h4>
        </figcaption>
</figure>

<hr>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// i = 0, the first item
</span><span class="c1"></span><span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
       
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><hr>
<p>dp :(back to front, one dimension dp)</p>
<p><strong>once nums[i] &lt;= j, get to the next loop</strong></p>
<figure><img src="/images/dp3.png"
         alt="image"/><figcaption>
            <h4>Partition Equal Subset Sum </h4>
        </figcaption>
</figure>

<hr>
<p>time：O(n^2)
space：O(n)</p>
<h4 id="q8last-stone-weight-ii">Q.8:Last Stone Weight II</h4>
<p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">https://leetcode-cn.com/problems/last-stone-weight-ii/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an array of integers stones where stones<span class="o">[</span>i<span class="o">]</span> is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x &lt;<span class="o">=</span> y. The result of this smash is:

If <span class="nv">x</span> <span class="o">==</span> y, both stones are destroyed, and
If x !<span class="o">=</span> y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the smallest possible weight of the left stone. If there are no stones left, <span class="k">return</span> 0.


</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[j]: bag j, get maximize weight dp[j]</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[j] = max(dp[j],  dp[j - stones[i]] +  stones[i]);</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = 0</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>for (int i = 0; i &lt; stones.length(); i++) {
for (int j = target; j &gt;= stones[i]; j&ndash;) {
dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
}
}</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[2, 4, 1, 1], target = 4</p>
</blockquote>
<blockquote>
<p>j     :   0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>2     :   0   0   2   2   2</p>
</blockquote>
<blockquote>
<p>4     :   0   0   2   2   4</p>
</blockquote>
<blockquote>
<p>1     :   0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>1     :   0   1   2   3   4</p>
</blockquote>
<h4 id="q9target-sum">Q.9:Target Sum</h4>
<p><a href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an integer array nums and an integer target.

You want to build an expression out of nums by adding one of the symbols <span class="s1">&#39;+&#39;</span> and <span class="s1">&#39;-&#39;</span> before each integer in nums and <span class="k">then</span> concatenate all the integers.

For example, <span class="k">if</span> <span class="nv">nums</span> <span class="o">=</span> <span class="o">[</span>2, 1<span class="o">]</span>, you can add a <span class="s1">&#39;+&#39;</span> before <span class="m">2</span> and a <span class="s1">&#39;-&#39;</span> before <span class="m">1</span> and concatenate them to build the expression <span class="s2">&#34;+2-1&#34;</span>.
Return the number of different expressions that you can build, which evaluates to target.

</code></pre></div><p>target = positive sum(left) - negative sum(right);</p>
<p>left - right = target</p>
<p>left + right = sum;</p>
<p>left = (sum + target) / 2</p>
<ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[j]: sum j, get maximize method dp[j]</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[j] += dp[j - nums[i]];</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = 1,</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em>
use one dimension dp</li>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[1, 1, 1, 1, 1], target = 3, bagsize = (3 + 4) /2 = 4;</p>
</blockquote>
<blockquote>
<p>b    :    0   1   2   3   4   dp[j] += dp[j - nums[i]];  dp[4] += dp[3], dp[3] += dp[2]; dp[2] += dp[1]; dp[1] += dp[0];</p>
</blockquote>
<blockquote>
<p>1     :   1   1   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   2   1   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   3   3   1   0</p>
</blockquote>
<blockquote>
<p>1     :   1   4   6   4   1</p>
</blockquote>
<blockquote>
<p>1     :   1   5   10   10   5</p>
</blockquote>
<p>details explains:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">target</span> <span class="o">+</span> <span class="n">sum</span><span class="o">)</span> <span class="o">%</span> <span class="n">2</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">(</span><span class="n">target</span> <span class="o">+</span> <span class="n">sum</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="n">size</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>
</code></pre></div><p>sum = pos_sum + neg_sum;</p>
<p>(sum - target) % 2 == 0, because the num in nums are all pos_Integer;</p>
<p>inition:</p>
<blockquote>
<p>b    :    0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>1     :   1   0   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   0   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   0   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   0   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   0   0   0   0</p>
</blockquote>
<hr>
<p>after the first row:</p>
<blockquote>
<p>b    :   0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>1     :   1   1   0   0   0   &lt;&mdash;-</p>
</blockquote>
<blockquote>
<p>1     :   1   1   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   1   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   1   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   1   0   0   0</p>
</blockquote>
<hr>
<p>after the second row:</p>
<blockquote>
<p>b    :   0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>1     :   1   1   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   2   1   0   0   &lt;&mdash;-</p>
</blockquote>
<blockquote>
<p>1     :   1   2   1   0   0   dp[j]</p>
</blockquote>
<blockquote>
<p>1     :   1   2   1   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   2   1   0   0</p>
</blockquote>
<hr>
<hr>
<p>after the third row:</p>
<blockquote>
<p>b    :   0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>1     :   1   1   0   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   2   1   0   0</p>
</blockquote>
<blockquote>
<p>1     :   1   3   3   1   0   &lt;&mdash;- dp[j]</p>
</blockquote>
<blockquote>
<p>1     :   1   3   3   1   0</p>
</blockquote>
<blockquote>
<p>1     :   1   3   3   1   0</p>
</blockquote>
<hr>
<h4 id="q10last-stone-weight-ii">Q.10:Last Stone Weight II</h4>
<p><a id="markdown-q.10%3Alast-stone-weight-ii" name="q.10%3Alast-stone-weight-ii"></a>
<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">https://leetcode-cn.com/problems/ones-and-zeroes/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an array of binary strings strs and two integers m and n.

Return the size of the largest subset of strs such that there are at most m 0<span class="s1">&#39;s and n 1&#39;</span>s in the subset.

A <span class="nb">set</span> x is a subset of a <span class="nb">set</span> y <span class="k">if</span> all elements of x are also elements of y.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i][j]: the max size of dp[i][j], has i&rsquo;s 0, j&rsquo;s 1;</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[i][j] = max(dp[i][j], dp[i - zeroNums][j - oneNums] + 1);</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0][0] = 0</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>for (int i = m; i &gt;= zeroNum; i&ndash;) {
for (int j = n; j &gt;= oneNum; j&ndash;) {
dp[i][j] = max(dp[i][j], dp[i -  zeroNum][j - oneNum] + 1);
}
}</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[10, 0001, 111001, 1, 0], m = 3, n = 3</p>
</blockquote>
<blockquote>
<p>j     :   0   1   2   3</p>
</blockquote>
<blockquote>
<p>0     :   0   0   0   0      &lt;&mdash;- Z: 1; O: 1 dp[3][3] = dp[2][2]</p>
</blockquote>
<blockquote>
<p>1     :   0   0   0   0      &lt;&mdash;- Z: 3; O: 1 dp[3][3] = dp[0][2]</p>
</blockquote>
<blockquote>
<p>2     :   0   0   0   0      &lt;&mdash;- Z: 0; O: 1  dp[1][1] = dp[1][0]</p>
</blockquote>
<blockquote>
<p>3     :   0   1   1   1</p>
</blockquote>
<hr>
<p>details:</p>
<p>every string is a item,</p>
<p>dp[i][j][k] : in [0, i], it can max numbers of j&rsquo;s 0, k&rsquo;s 1;</p>
<p>dp[i][j][k] = dp[i - 1][j][k] ;</p>
<p>dp[i][j][k] = dp[i - 1][j - zeroNum][k - oneNum] + 1 ;</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[][][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span> <span class="o">+</span> <span class="n">1</span><span class="o">][</span><span class="n">m</span> <span class="o">+</span> <span class="n">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="n">countZeroAndOne</span><span class="o">(</span><span class="n">Strs</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span>  <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">zeros</span> <span class="o">=</span> <span class="n">count</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">ones</span> <span class="o">=</span> <span class="n">count</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">zeros</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">ones</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">zeros</span><span class="o">][</span><span class="n">k</span> <span class="o">-</span> <span class="n">ones</span><span class="o">]);</span>
            <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">len</span><span class="o">][</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">countZeroAndOne</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">2</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">cnt</span><span class="o">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">]++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div><h4 id="q11coin-change-2">Q.11:Coin Change 2</h4>
<p><a id="markdown-q.11%3Acoin-change-2" name="q.11%3Acoin-change-2"></a>
<a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, <span class="k">return</span> 0.

You may assume that you have an infinite number of each kind of coin.

The answer is guaranteed to fit into a signed 32-bit integer.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[j]: the max ways to reach amount dp[j];</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[j] =dp[j] + dp[j - nums[i]];</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = 1</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<blockquote>
<p>for (int i = 0; i &lt; coins.size(); i++) {
for (int j = coins[i]; j &lt;= amount; j++) {
dp[j] += dp[j -  coins[i]];
// dp[0] must be 1; 
}
}</p>
</blockquote>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[1, 2, 5], amount = 5</p>
</blockquote>
<blockquote>
<p>j     :   0   1   2   3   4   5</p>
</blockquote>
<blockquote>
<p>1     :   1   1   1   1   1   1</p>
</blockquote>
<blockquote>
<p>2     :   1   1   2   2   3   3</p>
</blockquote>
<blockquote>
<p>5     :   1   1   2   2   3   4</p>
</blockquote>
<h4 id="q12combination-sum-iv">Q.12:Combination Sum IV</h4>
<p><a id="markdown-q.12%3Acombination-sum-iv" name="q.12%3Acombination-sum-iv"></a>
<a href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an array of distinct integers nums and a target integer target, <span class="k">return</span> the number of possible combinations that add up to target.

The answer is guaranteed to fit in a 32-bit integer.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]: the max ways to reach amount dp[i];</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[i] =dp[i] + dp[i - nums[j]];</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = 1</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p><strong>Combination： outer loop is items, inner loop is Knapsack</strong></p>
<p><strong>Permutation： outer loop is Knapsack, inner loop is items</strong></p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[1, 2, 3], amount = 4</p>
</blockquote>
<blockquote>
<p>i     :   0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>1     :   1   1   2   4   7</p>
</blockquote>
<p>dp[1] = dp[0] = 1</p>
<p>dp[2] = dp[1] + dp[0] = 2;</p>
<p>dp[3] = dp[2] + dp[1] + dp[0] = 4;</p>
<p>dp[4] = dp[3] + dp[2] + dp[1]  + dp[0] = 7;</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> 
       <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
           <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]];</span>
       <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">target</span><span class="o">];</span>
</code></pre></div><h4 id="q13climbing-stairs-improve">Q.13:Climbing Stairs improve</h4>
<p><a id="markdown-q.13%3Aclimbing-stairs-improve" name="q.13%3Aclimbing-stairs-improve"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are climbing a staircase. It takes n steps to reach the top.

Each <span class="nb">time</span> you can either climb <span class="m">1</span> or <span class="m">2</span> , <span class="m">3</span> ---- to m steps. In how many distinct ways can you climb to the top?

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]: the max ways to reach the top dp[i];</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[i] += dp[i - j];</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = 1</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p><strong>Combination： outer loop is items, inner loop is Knapsack</strong></p>
<p><strong>Permutation： outer loop is Knapsack, inner loop is items</strong></p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">weight</span> <span class="o">=</span> <span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">};</span>
<span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">weight</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> 
       <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
           <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">weight</span><span class="o">[</span><span class="n">j</span><span class="o">]];</span>
       <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</code></pre></div><h4 id="q14coin-change">Q.14:Coin Change</h4>
<p><a id="markdown-q.14%3Acoin-change" name="q.14%3Acoin-change"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, <span class="k">return</span> -1.

You may assume that you have an infinite number of each kind of coin.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[j]: the min coins need to reach the amount j ;</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[j] = min(dp[j], dp[j - coins[i]]);</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = 0;</p>
</blockquote>
<blockquote>
<p>the rest non-zero index should be Integer_MAX;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p><strong>Combination： outer loop is items, inner loop is Knapsack</strong></p>
<p><strong>Permutation： outer loop is Knapsack, inner loop is items</strong></p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[1, 2, 5], amount = 5</p>
</blockquote>
<blockquote>
<p>i     :        0   1   2   3   4   5</p>
</blockquote>
<blockquote>
<p>dp[j]     :    0   1   1   2   2    1</p>
</blockquote>
<h4 id="q15perfect-squares">Q.15:Perfect Squares</h4>
<p><a id="markdown-q.15%3Aperfect-squares" name="q.15%3Aperfect-squares"></a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an integer n, <span class="k">return</span> the least number of perfect square numbers that sum to n.

A perfect square is an integer that is the square of an integer<span class="p">;</span> in other words, it is the product of some integer with itself. For example, 1, 4, 9, and <span class="m">16</span> are perfect squares <span class="k">while</span> <span class="m">3</span> and <span class="m">11</span> are not.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]:</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<blockquote>
<p>dp[j] = dp[j - i * i];</p>
</blockquote>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = 0;</p>
</blockquote>
<blockquote>
<p>the rest non-zero index should be Integer_MAX;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p><strong>Combination： outer loop is items, inner loop is Knapsack</strong></p>
<p><strong>Permutation： outer loop is Knapsack, inner loop is items</strong></p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>n = 5</p>
</blockquote>
<blockquote>
<p>i     :        0   1   2   3   4   5</p>
</blockquote>
<blockquote>
<p>dp[i]     :    0   1   1   2   2    1</p>
</blockquote>
<h4 id="q16word-break">Q.16:Word Break</h4>
<p><a id="markdown-q.16%3Aword-break" name="q.16%3Aword-break"></a>
<a href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given a string s and a dictionary of strings wordDict, <span class="k">return</span> <span class="nb">true</span> <span class="k">if</span> s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple <span class="nb">times</span> in the segmentation.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]: string length at i, dp[i] is true, has one or multiple words in dict.</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>[0, j , i],</p>
<p>dp[j] is true, &amp;&amp; words in [j, i] also in dict, then dp[i] is true;</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = true;</p>
</blockquote>
<blockquote>
<p>the rest non-zero index should be false;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p><strong>Combination： outer loop is items, inner loop is Knapsack</strong></p>
<p><strong>Permutation： outer loop is Knapsack, inner loop is items</strong></p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>s = &ldquo;leetcode&rdquo;, wordDict = [&ldquo;leet&rdquo;, &ldquo;code&rdquo;]</p>
</blockquote>
<blockquote>
<p>i     :        0   1   2   3   4   5   6   7   8</p>
</blockquote>
<blockquote>
<p>dp[i]     :    1   0   0   0   1</p>
</blockquote>
<h4 id="q17house-robber">Q.17:House Robber</h4>
<p><a id="markdown-q.17%3Ahouse-robber" name="q.17%3Ahouse-robber"></a>
<a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police <span class="k">if</span> two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, <span class="k">return</span> the maximum amount of money you can rob tonight without alerting the police.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]: [0, i] get the max amount money dp[i]</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>dp[i] = max(dp[i -2] + nums[i], dp[i -1]);</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0] = nums[0];</p>
</blockquote>
<blockquote>
<p>dp[1] = max(nums[0], nums[1]);</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>front to back</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[2, 7, 9, 3, 1]</p>
</blockquote>
<blockquote>
<p>i     :        0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>dp[i]     :    2   7   11  11  12</p>
</blockquote>
<h4 id="q18house-robber-ii">Q.18:House Robber II</h4>
<p><a id="markdown-q.18%3Ahouse-robber-ii" name="q.18%3Ahouse-robber-ii"></a>
<a href="https://leetcode-cn.com/problems/house-robber-ii/">https://leetcode-cn.com/problems/house-robber-ii/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police <span class="k">if</span> two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, <span class="k">return</span> the maximum amount of money you can rob tonight without alerting the police.


</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<blockquote>
<p>dp[i]: [0, i] get the max amount money dp[i]</p>
</blockquote>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>dp[i] = max(dp[i -2] + nums[i], dp[i -1]);</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<p>Math.max(helper(nums, 0, n - 1), helper(nums, 1, n));</p>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>front to back</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<blockquote>
<p>[2, 7, 9, 3, 1]</p>
</blockquote>
<blockquote>
<p>i     :        0   1   2   3   4</p>
</blockquote>
<blockquote>
<p>dp[i]     :</p>
</blockquote>
<h4 id="q20-best-time-to-buy-and-sell-stock">Q.20: Best Time to Buy and Sell Stock</h4>
<p><a id="markdown-q.20%3A-best-time-to-buy-and-sell-stock" name="q.20%3A-best-time-to-buy-and-sell-stock"></a>
<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an array prices where prices<span class="o">[</span>i<span class="o">]</span> is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, <span class="k">return</span> 0.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>tree dp, return int[val1, val2] : val1: not include current value, val2: include current value;</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<p>if (cur == null) return int[]{0, 0};</p>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>include root:
int val1 = cur.val + left[0] + right[0];</p>
<p>not include root:
int val2 = max(left[0], left[1]) +  max(right[0], right[1]);
return {val2, val1};</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">            <span class="n">3</span><span class="o">{</span><span class="n">6</span><span class="o">,</span> <span class="n">7</span><span class="o">}</span>
        <span class="o">/</span>       <span class="err">\</span>
      <span class="n">2</span><span class="o">{</span><span class="n">3</span><span class="o">,</span> <span class="n">2</span><span class="o">}</span>      <span class="n">3</span><span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">3</span><span class="o">}</span>
        <span class="err">\</span>           <span class="err">\</span>
        <span class="n">3</span><span class="o">{</span><span class="n">0</span><span class="o">,</span> <span class="n">3</span><span class="o">}</span>      <span class="n">1</span><span class="o">{}</span>
</code></pre></div><h4 id="q19-house-robber-iii">Q.19: House Robber III</h4>
<p><a id="markdown-q.19%3A-house-robber-iii" name="q.19%3A-house-robber-iii"></a>
<a href="https://leetcode-cn.com/problems/house-robber-ii/">https://leetcode-cn.com/problems/house-robber-ii/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">The thief has found himself a new place <span class="k">for</span> his thievery again. There is only one entrance to this area, called root.

Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police <span class="k">if</span> two directly-linked houses were broken into on the same night.

Given the root of the binary tree, <span class="k">return</span> the maximum amount of money the thief can rob without alerting the police.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>tree dp, return int[val1, val2] : val1: not include current value, val2: include current value;</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<p>if (cur == null) return int[]{0, 0};</p>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>include root:
int val1 = cur.val + left[0] + right[0];</p>
<p>not include root:
int val2 = max(left[0], left[1]) +  max(right[0], right[1]);
return {val2, val1};</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">            <span class="n">3</span><span class="o">{</span><span class="n">6</span><span class="o">,</span> <span class="n">7</span><span class="o">}</span>
        <span class="o">/</span>       <span class="err">\</span>
      <span class="n">2</span><span class="o">{</span><span class="n">3</span><span class="o">,</span> <span class="n">2</span><span class="o">}</span>      <span class="n">3</span><span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">3</span><span class="o">}</span>
        <span class="err">\</span>           <span class="err">\</span>
        <span class="n">3</span><span class="o">{</span><span class="n">0</span><span class="o">,</span> <span class="n">3</span><span class="o">}</span>      <span class="n">1</span><span class="o">{}</span>
</code></pre></div><h4 id="q20-best-time-to-buy-and-sell-stock-1">Q.20: Best Time to Buy and Sell Stock</h4>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an array prices where prices<span class="o">[</span>i<span class="o">]</span> is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, <span class="k">return</span> 0.

</code></pre></div><ul>
<li>
<p><em><strong>sp1. dp table and index meaning</strong></em></p>
</li>
<li>
<p><em><strong>sp2. recurrence formula</strong></em>
dp[i][0]:</p>
</li>
<li>
<p>i days hold stock</p>
<ul>
<li>i -1 days hold stock, the amount money: dp[i - 1][0]</li>
<li>i buy the stock, the amount money: -prices[i]</li>
<li>dp[i][0] = max(dp[i -1][0], -prices[i]);</li>
</ul>
</li>
</ul>
<p>dp[i][1]:</p>
<ul>
<li>
<p>i days not hold stock</p>
<ul>
<li>i -1 days not hold stock, the amount money: dp[i - 1][1]</li>
<li>i sell the stock, the amount money: dp[i - 1][0] + prices[i]</li>
<li>dp[i][1] = max(dp[i -1][1], dp[i -1][0] + prices[i]);</li>
</ul>
</li>
<li>
<p><em><strong>sp3. initial values</strong></em></p>
</li>
</ul>
<blockquote>
<p>dp[0][0] -= prices[0];</p>
</blockquote>
<blockquote>
<p>dp[0][1] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>front to back</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="o">[</span><span class="n">7</span><span class="o">,</span> <span class="n">1</span><span class="o">,</span> <span class="n">5</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">6</span><span class="o">,</span> <span class="n">4</span><span class="o">]</span>

       <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span>  <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]</span>
        <span class="o">-</span><span class="n">7</span>          <span class="n">0</span>
        <span class="o">-</span><span class="n">1</span>          <span class="n">0</span>
        <span class="o">-</span><span class="n">1</span>          <span class="n">4</span>
        <span class="o">-</span><span class="n">1</span>          <span class="n">4</span>
        <span class="o">-</span><span class="n">1</span>          <span class="n">5</span>
        <span class="o">-</span><span class="n">1</span>          <span class="n">5</span>
</code></pre></div><h4 id="q21-best-time-to-buy-and-sell-stock-ii">Q.21: Best Time to Buy and Sell Stock II</h4>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an integer array prices where prices<span class="o">[</span>i<span class="o">]</span> is the price of a given stock on the ith day.

On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it <span class="k">then</span> immediately sell it on the same day.

Find and <span class="k">return</span> the maximum profit you can achieve.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][0]:</p>
<ul>
<li>i days hold stock
<ul>
<li>i -1 days hold stock, the amount money: dp[i - 1][0]</li>
<li>i buy the stock, the amount money: dp[i -1][1] - prices[i]</li>
<li>dp[i][0] = max(dp[i -1][0], dp[i -1][1]-prices[i]);</li>
</ul>
</li>
</ul>
<p>dp[i][1]:</p>
<ul>
<li>
<p>i days not hold stock</p>
<ul>
<li>i -1 days not hold stock, the amount money: dp[i - 1][1]</li>
<li>i sell the stock, the amount money: dp[i - 1][0] + prices[i]</li>
<li>dp[i][1] = max(dp[i -1][1], dp[i -1][0] + prices[i]);</li>
</ul>
</li>
<li>
<p><em><strong>sp3. initial values</strong></em></p>
</li>
</ul>
<blockquote>
<p>dp[0][0] -= prices[0];</p>
</blockquote>
<blockquote>
<p>dp[0][1] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>front to back</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="o">[</span><span class="n">7</span><span class="o">,</span> <span class="n">1</span><span class="o">,</span> <span class="n">5</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">6</span><span class="o">,</span> <span class="n">4</span><span class="o">]</span>

       <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span>  <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]</span>
    
</code></pre></div><h4 id="q22-best-time-to-buy-and-sell-stock-iii">Q.22: Best Time to Buy and Sell Stock III</h4>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an array prices where prices<span class="o">[</span>i<span class="o">]</span> is the price of a given stock on the ith day.

Find the maximum profit you can achieve. You may <span class="nb">complete</span> at most two transactions.

Note: You may not engage in multiple transactions simultaneously <span class="o">(</span>i.e., you must sell the stock before you buy again<span class="o">)</span>.

</code></pre></div><ul>
<li>
<p><em><strong>sp1. dp table and index meaning</strong></em></p>
<p>the 5 situation of a day:</p>
<ul>
<li>
<ol start="0">
<li>do nothing</li>
</ol>
</li>
<li>
<ol>
<li>the first time buy in</li>
</ol>
</li>
<li>
<ol start="2">
<li>the first time sell out</li>
</ol>
</li>
<li>
<ol start="3">
<li>the second time buy in</li>
</ol>
</li>
<li>
<ol start="4">
<li>the second time sell out</li>
</ol>
</li>
</ul>
<p>dp[i][j] , j [0, 4] situation</p>
</li>
<li>
<p><em><strong>sp2. recurrence formula</strong></em></p>
</li>
</ul>
<p>dp[i][1]:</p>
<ul>
<li>
<p>i days buy in stock:dp[i][1] = dp[i - 1][0] - prices[i];</p>
</li>
<li>
<p>i days do nothing, following i -1 buy in situation : dp[i][1] = dp[i - 1][1]</p>
</li>
<li>
<p>dp[i][1] = max(dp[i -1][1], dp[i -1][0]-prices[i]);</p>
</li>
</ul>
<p>dp[i][2]:</p>
<ul>
<li>
<p>i days sell out stock:dp[i][2] = dp[i - 1][1] + prices[i];</p>
</li>
<li>
<p>i days do nothing: dp[i][2] = dp[i - 1][2]</p>
</li>
<li>
<p>dp[i][2] = max(dp[i -1][2], dp[i -1][1] + prices[i]);</p>
</li>
<li>
<p>dp[i][3] = max(dp[i -1][3], dp[i -1][2] - prices[i]);</p>
</li>
<li>
<p>dp[i][4] = max(dp[i -1][4], dp[i -1][3] + prices[i]);</p>
</li>
<li>
<p><em><strong>sp3. initial values</strong></em></p>
</li>
</ul>
<blockquote>
<p>dp[0][0] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][1] -= prices[0];</p>
</blockquote>
<blockquote>
<p>dp[0][2] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][3] -= prices[0];</p>
</blockquote>
<blockquote>
<p>dp[0][4] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>front to back</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="o">[</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">,</span> <span class="n">5</span><span class="o">]</span>
<span class="n">i</span>   <span class="n">j</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>   <span class="n">4</span>

<span class="n">0</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">0</span>
<span class="n">1</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">1</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">1</span>
<span class="n">2</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">2</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">2</span>
<span class="n">3</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">3</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">3</span>
<span class="n">4</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">4</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">4</span>
       
</code></pre></div><h4 id="q23-best-time-to-buy-and-sell-stock-iii">Q.23: Best Time to Buy and Sell Stock III</h4>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an integer array prices where prices<span class="o">[</span>i<span class="o">]</span> is the price of a given stock on the ith day, and an integer k.

Find the maximum profit you can achieve. You may <span class="nb">complete</span> at most k transactions.

Note: You may not engage in multiple transactions simultaneously <span class="o">(</span>i.e., you must sell the stock before you buy again<span class="o">)</span>.

</code></pre></div><ul>
<li>
<p><em><strong>sp1. dp table and index meaning</strong></em></p>
<p>the 5 situation of a day:</p>
<ul>
<li>
<ol start="0">
<li>do nothing</li>
</ol>
</li>
<li>
<ol>
<li>the first time buy in</li>
</ol>
</li>
<li>
<ol start="2">
<li>the first time sell out</li>
</ol>
</li>
<li>
<ol start="3">
<li>the second time buy in</li>
</ol>
</li>
<li>
<ol start="4">
<li>the second time sell out</li>
</ol>
</li>
</ul>
<p>dp[i][j] , j [0, 2 * k + 1] situation</p>
</li>
<li>
<p><em><strong>sp2. recurrence formula</strong></em></p>
</li>
</ul>
<p>dp[i][1]:</p>
<ul>
<li>
<p>i days buy in stock:dp[i][1] = dp[i - 1][0] - prices[i];</p>
</li>
<li>
<p>i days do nothing, following i -1 buy in situation : dp[i][1] = dp[i - 1][1]</p>
</li>
<li>
<p>dp[i][1] = max(dp[i -1][1], dp[i -1][0]-prices[i]);</p>
</li>
</ul>
<p>dp[i][2]:</p>
<ul>
<li>
<p>i days sell out stock:dp[i][2] = dp[i - 1][1] + prices[i];</p>
</li>
<li>
<p>i days do nothing: dp[i][2] = dp[i - 1][2]</p>
</li>
<li>
<p>dp[i][2] = max(dp[i -1][2], dp[i -1][1] + prices[i]);</p>
</li>
<li>
<p>dp[i][3] = max(dp[i -1][3], dp[i -1][2] - prices[i]);</p>
</li>
<li>
<p>dp[i][4] = max(dp[i -1][4], dp[i -1][3] + prices[i]);</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">2</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="o">}</span>

</code></pre></div><ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0][0] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][1] -= prices[0];</p>
</blockquote>
<blockquote>
<p>dp[0][2] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][3] -= prices[0];</p>
</blockquote>
<blockquote>
<p>dp[0][4] = 0;</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
<span class="o">}</span>

</code></pre></div><ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>front to back</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="o">[</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">,</span> <span class="n">5</span><span class="o">]</span>
<span class="n">i</span>   <span class="n">j</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>   <span class="n">4</span>

<span class="n">0</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">0</span>
<span class="n">1</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">1</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">1</span>
<span class="n">2</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">2</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">2</span>
<span class="n">3</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">3</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">3</span>
<span class="n">4</span>          <span class="n">0</span>   <span class="o">-</span><span class="n">1</span>   <span class="n">4</span>   <span class="o">-</span><span class="n">1</span>  <span class="n">4</span>
       
</code></pre></div><h4 id="q24-best-time-to-buy-and-sell-stock-with-cooldown">Q.24: Best Time to Buy and Sell Stock with Cooldown</h4>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an array prices where prices<span class="o">[</span>i<span class="o">]</span> is the price of a given stock on the ith day.

Find the maximum profit you can achieve. You may <span class="nb">complete</span> as many transactions as you like <span class="o">(</span>i.e., buy one and sell one share of the stock multiple <span class="nb">times</span><span class="o">)</span> with the following restrictions:

After you sell your stock, you cannot buy stock on the next day <span class="o">(</span>i.e., cooldown one day<span class="o">)</span>.
Note: You may not engage in multiple transactions simultaneously <span class="o">(</span>i.e., you must sell the stock before you buy again<span class="o">)</span>.

</code></pre></div><ul>
<li>
<p><em><strong>sp1. dp table and index meaning</strong></em></p>
<p>the j situation of a day:</p>
<ul>
<li>
<ol start="0">
<li>buy in (or bought in before today)</li>
</ol>
</li>
<li>
<ol>
<li>sell out and you can buy in anytime</li>
</ol>
</li>
<li>
<ol start="2">
<li>sell out today</li>
</ol>
</li>
<li>
<ol start="3">
<li>cooldown</li>
</ol>
</li>
</ul>
</li>
<li>
<p><em><strong>sp2. recurrence formula</strong></em></p>
</li>
</ul>
<p>dp[i][0]:</p>
<ul>
<li>i-1 days bought in stock:dp[i][0] = dp[i - 1][0];</li>
<li>i day buy in: i -1 is cooldown situdation: dp[i][3] - prices[i];</li>
<li>i day buy in: i -1 is selling out situdation: dp[i][1] - prices[i];</li>
</ul>
<p>dp[i][0] = max( dp[i - 1][0], max(dp[i][3] - prices[i], dp[i][1] - prices[i]));</p>
<p>dp[i][1]:</p>
<ul>
<li>i -1 days sell out stock:dp[i][1] = dp[i - 1][1] ;</li>
<li>i -1 day is cooldown day: dp[i][2] = dp[i - 1][3]</li>
</ul>
<p>dp[i][1] = max( dp[i - 1][1], dp[i -1][3]);</p>
<p>dp[i][2]:</p>
<ul>
<li>i -1 days buy in stock, and sell out today:dp[i][2] = dp[i - 1][0] + prices[i];</li>
</ul>
<p>dp[i][2] = dp[i - 1][0] + prices[i];</p>
<p>dp[i][3]:</p>
<ul>
<li>i -1 days sell out stock:dp[i][3] = dp[i - 1][2];</li>
</ul>
<p>dp[i][3] = dp[i - 1][2];</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">0</span><span class="o">],</span> <span class="n">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">3</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span><span class="n">1</span><span class="o">][</span><span class="n">3</span><span class="o">]);</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
<span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">3</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">2</span><span class="o">];</span>
</code></pre></div><ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[0][0] = -= prices[0];</p>
</blockquote>
<blockquote>
<p>dp[0][1] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][2] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][3] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>front to back</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="o">[</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">2</span><span class="o">]</span>
<span class="n">i</span>   <span class="n">j</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>   

<span class="n">0</span>          <span class="o">-</span><span class="n">1</span>   <span class="n">0</span>   <span class="n">0</span>    <span class="n">0</span>  
<span class="n">1</span>          <span class="o">-</span><span class="n">1</span>   <span class="n">0</span>   <span class="n">1</span>    <span class="n">0</span>  
<span class="n">2</span>          <span class="o">-</span><span class="n">1</span>   <span class="n">0</span>   <span class="n">2</span>    <span class="n">1</span>  
<span class="n">3</span>           <span class="n">1</span>   <span class="n">1</span>  <span class="o">-</span><span class="n">1</span>    <span class="n">2</span>  
<span class="n">4</span>           <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>    <span class="o">-</span><span class="n">1</span>  
       
</code></pre></div><h4 id="q25-maximum-length-of-repeated-subarray">Q.25: Maximum Length of Repeated Subarray</h4>
<p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given two integer arrays nums1 and nums2, <span class="k">return</span> the maximum length of a subarray that appears in both arrays.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]: [0, i -1] and[0, j -1], the maximum length of repeated subarray</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (A[i -1] == B[j - 1]) dp[i][j]: dp[i - 1][j - 1] + 1</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][j] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>front to back</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">B</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span><span class="n">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">B</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div><ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="o">[</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">1</span><span class="o">]</span>     <span class="n">B</span><span class="o">:</span>  <span class="o">[</span><span class="n">3</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">1</span><span class="o">,</span> <span class="n">4</span><span class="o">,</span> <span class="n">7</span><span class="o">]</span>
<span class="nl">
</span><span class="nl">   B:</span>       <span class="n">3</span>   <span class="n">2</span>   <span class="n">1</span>   <span class="n">4</span>   <span class="n">7</span>   
        <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>
<span class="n">1</span>       <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">1</span>   <span class="n">0</span>   <span class="n">0</span>   
<span class="n">2</span>       <span class="n">0</span>   <span class="n">0</span>   <span class="n">1</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   
<span class="n">3</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   
<span class="n">2</span>       <span class="n">0</span>   <span class="n">0</span>   <span class="n">2</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>      
<span class="n">1</span>       <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">3</span>   <span class="n">0</span>   <span class="n">0</span>      
       
</code></pre></div><h4 id="q26-longest-common-subsequence">Q.26: Longest Common Subsequence</h4>
<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given two strings text1 and text2, <span class="k">return</span> the length of their longest common subsequence. If there is no common subsequence, <span class="k">return</span> 0.

A subsequence of a string is a new string generated from the original string with some characters <span class="o">(</span>can be none<span class="o">)</span> deleted without changing the relative order of the remaining characters.

For example, <span class="s2">&#34;ace&#34;</span> is a subsequence of <span class="s2">&#34;abcde&#34;</span>.
A common subsequence of two strings is a subsequence that is common to both strings.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]: [0, i -1] and[0, j -1], the longest common of repeated Subsequence</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (A[i -1] == B[j - 1]) dp[i][j]: dp[i - 1][j - 1] + 1</p>
<p>if (A[i -1] != B[j - 1]) dp[i][j]: Math.max(dp[i - 1][j], dp[i][j - 1])</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][j] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<table>
<thead>
<tr>
<th>dp[i - 1][j - 1]</th>
<th>dp[i - 1][j]</th>
</tr>
</thead>
<tbody>
<tr>
<td>dp[i][j - 1]       dp[i][j]</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="s">&#34;abcde&#34;</span>    <span class="n">B</span><span class="o">:</span>  <span class="s">&#34;ace&#34;</span>
<span class="nl">
</span><span class="nl">   B:</span>       <span class="n">a</span>   <span class="n">c</span>   <span class="n">e</span>    
        <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   
<span class="n">a</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   
<span class="n">b</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>       
<span class="n">c</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">2</span>    
<span class="n">d</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">2</span>       
<span class="n">e</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>       
       
</code></pre></div><h4 id="q27--uncrossed-lines">Q.27:  Uncrossed Lines</h4>
<p><a href="https://leetcode-cn.com/problems/uncrossed-lines/">https://leetcode-cn.com/problems/uncrossed-lines/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 <span class="o">(</span>in the order they are given<span class="o">)</span> on two separate horizontal lines.

We may draw connecting lines: a straight line connecting two numbers nums1<span class="o">[</span>i<span class="o">]</span> and nums2<span class="o">[</span>j<span class="o">]</span> such that:

nums1<span class="o">[</span>i<span class="o">]</span> <span class="o">==</span> nums2<span class="o">[</span>j<span class="o">]</span>, and
the line we draw does not intersect any other connecting <span class="o">(</span>non-horizontal<span class="o">)</span> line.
Note that a connecting line cannot intersect even at the endpoints <span class="o">(</span>i.e., each number can only belong to one connecting line<span class="o">)</span>.

Return the maximum number of connecting lines we can draw in this way.


</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]: [0, i -1] and[0, j -1], the longest common of repeated Subsequence</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (A[i -1] == B[j - 1]) dp[i][j]: dp[i - 1][j - 1] + 1</p>
<p>if (A[i -1] != B[j - 1]) dp[i][j]: Math.max(dp[i - 1][j], dp[i][j - 1])</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][j] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<table>
<thead>
<tr>
<th>dp[i - 1][j - 1]</th>
<th>dp[i - 1][j]</th>
</tr>
</thead>
<tbody>
<tr>
<td>dp[i][j - 1]       dp[i][j]</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="s">&#34;abcde&#34;</span>    <span class="n">B</span><span class="o">:</span>  <span class="s">&#34;ace&#34;</span>
<span class="nl">
</span><span class="nl">   B:</span>       <span class="n">a</span>   <span class="n">c</span>   <span class="n">e</span>    
        <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   
<span class="n">a</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   
<span class="n">b</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>       
<span class="n">c</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">2</span>    
<span class="n">d</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">2</span>       
<span class="n">e</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>       
       
</code></pre></div><h4 id="q28-is-subsequence">Q.28: Is Subsequence</h4>
<p><a href="https://leetcode-cn.com/problems/is-subsequence/">https://leetcode-cn.com/problems/is-subsequence/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given two strings s and t, <span class="k">return</span> <span class="nb">true</span> <span class="k">if</span> s is a subsequence of t, or <span class="nb">false</span> otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some <span class="o">(</span>can be none<span class="o">)</span> of the characters without disturbing the relative positions of the remaining characters. <span class="o">(</span>i.e., <span class="s2">&#34;ace&#34;</span> is a subsequence of <span class="s2">&#34;abcde&#34;</span> <span class="k">while</span> <span class="s2">&#34;aec&#34;</span> is not<span class="o">)</span>.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]: [0, i -1] and[0, j -1], the longest common of repeated Subsequence</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (A[i -1] == B[j - 1]) dp[i][j]: dp[i - 1][j - 1] + 1</p>
<p>if (A[i -1] != B[j - 1]) dp[i][j]: dp[i][j - 1]</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = 0;</p>
</blockquote>
<blockquote>
<p>dp[0][0] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<table>
<thead>
<tr>
<th>dp[i - 1][j - 1]</th>
<th>dp[i - 1][j]</th>
</tr>
</thead>
<tbody>
<tr>
<td>dp[i][j - 1]       dp[i][j]</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="s">&#34;ahbgdc&#34;</span>    <span class="n">B</span><span class="o">:</span>  <span class="s">&#34;abc&#34;</span>
<span class="nl">
</span><span class="nl">   B:</span>       <span class="n">a</span>   <span class="n">h</span>   <span class="n">b</span>   <span class="n">g</span>   <span class="n">d</span>   <span class="n">c</span>       
        <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>    
<span class="n">a</span>       <span class="n">0</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>
<span class="n">b</span>       <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">2</span>   <span class="n">2</span>   <span class="n">2</span>   <span class="n">2</span> 
<span class="n">c</span>       <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">3</span> 
    
       
</code></pre></div><h4 id="q29-distinct-subsequences">Q.29: Distinct Subsequences</h4>
<p><a href="https://leetcode-cn.com/problems/distinct-subsequences/">https://leetcode-cn.com/problems/distinct-subsequences/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given two strings s and t, <span class="k">return</span> the number of distinct subsequences of s which equals t.

A string<span class="s1">&#39;s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters&#39;</span> relative positions. <span class="o">(</span>i.e., <span class="s2">&#34;ACE&#34;</span> is a subsequence of <span class="s2">&#34;ABCDE&#34;</span> <span class="k">while</span> <span class="s2">&#34;AEC&#34;</span> is not<span class="o">)</span>.

The <span class="nb">test</span> cases are generated so that the answer fits on a 32-bit signed integer.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]: the numbers of [0, j-1] B  in [0, i -1 ]A;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (A[i -1] == B[j - 1]) dp[i][j] =dp[i - 1][j - 1] +  dp[i - 1][j]</p>
<p><strong>A : abcc    B: abc   A[3] == B[2], but A[0]A[1]A[2] = B[0]B[1]B[2], or A[0]A[1]A[3] = B[0]B[1]B[2]</strong></p>
<p>if (A[i -1] != B[j - 1]) dp[i][j] =  dp[i - 1][j]</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = 1;</p>
</blockquote>
<blockquote>
<p>dp[0][j] = 0;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<p>from left to right, up to down</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="s">&#34;baegg&#34;</span>    <span class="n">B</span><span class="o">:</span>  <span class="s">&#34;bag&#34;</span>
<span class="nl">
</span><span class="nl">   B:</span>       <span class="n">b</span>   <span class="n">a</span>   <span class="n">g</span>     
        <span class="n">1</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>  
<span class="n">b</span>       <span class="n">1</span>   <span class="n">1</span>   <span class="n">0</span>   <span class="n">0</span>   
<span class="n">a</span>       <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">0</span>   
<span class="n">e</span>       <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">0</span>
<span class="n">g</span>       <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>
<span class="n">g</span>       <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>   <span class="n">2</span>     
    
       
</code></pre></div><h4 id="q30--delete-operation-for-two-strings">Q.30:  Delete Operation for Two Strings</h4>
<p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">https://leetcode-cn.com/problems/delete-operation-for-two-strings/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given two strings word1 and word2, <span class="k">return</span> the minimum number of steps required to make word1 and word2 the same.

In one step, you can delete exactly one character in either string.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]: the least numbers of deleting characters making [0, j-1] B  equals [0, i -1 ]A;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (A[i -1] == B[j - 1]) dp[i][j] =dp[i - 1][j - 1]</p>
<p>if (A[i -1] != B[j - 1])</p>
<ul>
<li>del A[i -1], dp[i][j] =  dp[i - 1][j] + 1</li>
<li>del B[j -1], dp[i][j] =  dp[i][j - 1] + 1</li>
<li>del del A[i -1] &amp;&amp; B[j -1], dp[i][j] =  dp[i -1][j - 1] + 2</li>
</ul>
<p>dp[i][j]  = min( dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i -1][j - 1] + 2)</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = i; (B is empty)</p>
</blockquote>
<blockquote>
<p>dp[0][j] = j;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<p>from left to right, up to down</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="s">&#34;sea&#34;</span>    <span class="n">B</span><span class="o">:</span>  <span class="s">&#34;eat&#34;</span>
<span class="nl">
</span><span class="nl">   B:</span>       <span class="n">e</span>   <span class="n">a</span>   <span class="n">t</span>     
        <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>  
<span class="n">s</span>       <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>   <span class="n">4</span>   
<span class="n">e</span>       <span class="n">2</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>   
<span class="n">a</span>       <span class="n">3</span>   <span class="n">2</span>   <span class="n">1</span>   <span class="n">2</span>       
</code></pre></div><h4 id="q31---edit-distance">Q.31:   Edit Distance</h4>
<p><a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given two strings word1 and word2, <span class="k">return</span> the minimum number of operations required to convert word1 to word2.

You have the following three operations permitted on a word:

Insert a character
Delete a character
Replace a character

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]: the least distance of edit characters making [0, j-1] B  equals [0, i -1 ]A;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (A[i -1] == B[j - 1]) dp[i][j] =dp[i - 1][j - 1]</p>
<p>if (A[i -1] != B[j - 1])</p>
<ul>
<li>del A[i -1], dp[i][j] =  dp[i - 1][j] + 1</li>
<li>del B[j -1], dp[i][j] =  dp[i][j - 1] + 1</li>
<li>replace  A[i -1] &amp;&amp; B[j -1], dp[i][j] =  dp[i -1][j - 1] + 1</li>
</ul>
<p>dp[i][j]  = min( dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i -1][j - 1] + 1)</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][0] = i; (B is empty)</p>
</blockquote>
<blockquote>
<p>dp[0][j] = j;</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<p>from left to right, up to down</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="s">&#34;horse&#34;</span>    <span class="n">B</span><span class="o">:</span>  <span class="s">&#34;ros&#34;</span>
<span class="nl">
</span><span class="nl">   B:</span>       <span class="n">r</span>   <span class="n">o</span>   <span class="n">s</span>     
        <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>  
<span class="n">h</span>       <span class="n">1</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">3</span>   
<span class="n">o</span>       <span class="n">2</span>   <span class="n">2</span>   <span class="n">1</span>   <span class="n">2</span>   
<span class="n">r</span>       <span class="n">3</span>   <span class="n">2</span>   <span class="n">2</span>   <span class="n">2</span>  
<span class="n">s</span>       <span class="n">4</span>   <span class="n">3</span>   <span class="n">3</span>   <span class="n">2</span>  
<span class="n">e</span>       <span class="n">5</span>   <span class="n">4</span>   <span class="n">4</span>   <span class="n">3</span>               
</code></pre></div><h4 id="q32--palindromic-substrings">Q.32:  Palindromic Substrings</h4>
<p><a href="https://leetcode-cn.com/problems/palindromic-substrings/">https://leetcode-cn.com/problems/palindromic-substrings/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given a string s, <span class="k">return</span> the number of palindromic substrings in it.

A string is a palindrome when it reads the same backward as forward.

A substring is a contiguous sequence of characters within the string.
</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]:  substring between [i, j] is Palindromic, then dp[i][j] is true;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (S[i ] == S[j ])</p>
<ul>
<li>if (j - i &lt;= 1) dp[i][j] = true; // a or aa</li>
<li>if (j - 1 &gt; 1) dp[i + 1][j -1] = true, then&hellip; //cabac</li>
</ul>
<p>if (S[i ] != S[j ]) dp[i][j] = false</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][j] = false</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<p>from left to right, down to up</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="s">&#34;aaa&#34;</span>   

      
        <span class="n">1</span>   <span class="n">1</span>   <span class="n">1</span>     
        <span class="n">0</span>   <span class="n">1</span>   <span class="n">1</span>      
        <span class="n">0</span>   <span class="n">0</span>   <span class="n">1</span>      
              
</code></pre></div><h4 id="q33--palindromic-subsequence">Q.33:  Palindromic Subsequence</h4>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given a string s, find the longest palindromic subsequence<span class="err">&#39;</span>s length in s.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

</code></pre></div><ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]:  substring between [i, j] is Palindromic, then dp[i][j] is true;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>if (S[i ] == S[j ])  dp[i][j] = dp[i + 1][j -1] + 2;</p>
<p>if (S[i ] != S[j ]) dp[i][j] = max(dp[i + 1][j], dp[i][j -1]);</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<blockquote>
<p>dp[i][j] = 1 ; if (S[i ] == S[j ])  dp[i][j] = dp[i + 1][j -1] + 2;</p>
</blockquote>
<blockquote>
<p>dp[i][j] = 0; if (S[i ] != S[j ]) dp[i][j] = max(dp[i + 1][j], dp[i][j -1]);</p>
</blockquote>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<p>from left to right, down to up</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="n">A</span><span class="o">:</span>  <span class="s">&#34;cbbd&#34;</span>   

        <span class="n">c</span>   <span class="n">b</span>   <span class="n">b</span>   <span class="n">d</span>
   <span class="n">c</span>    <span class="n">1</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">2</span>     
   <span class="n">b</span>    <span class="n">0</span>   <span class="n">1</span>   <span class="n">2</span>   <span class="n">2</span>      
   <span class="n">b</span>    <span class="n">0</span>   <span class="n">0</span>   <span class="n">1</span>   <span class="n">1</span>  
   <span class="n">d</span>    <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">1</span>   
</code></pre></div><h4 id="q34--triangle">Q.34:  Triangle</h4>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given a triangle array, <span class="k">return</span> the minimum path sum from top to bottom.

For each step, you may move to an adjacent number of the row below. More formally, <span class="k">if</span> you are on index i on the current row, you may move to either index i or index i + <span class="m">1</span> on the next row.
</code></pre></div><p><strong>method top to bottom</strong></p>
<ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]:  from top to [i, j], the minimum path sum;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>dp[i][j] = min(dp[i - 1][j -1], dp[i - 1][j]) + c[i][j];</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<p>dp[0][0] = c[i][j]</p>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<p>up  to down</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">   

                        <span class="n">dp</span>
       <span class="n">2</span>                <span class="n">2</span>
       <span class="n">3</span>   <span class="n">4</span>            <span class="n">5</span>
       <span class="n">6</span>   <span class="n">5</span>   <span class="n">7</span>        <span class="n">10</span>
       <span class="n">4</span>   <span class="n">1</span>   <span class="n">8</span>   <span class="n">3</span>    <span class="n">11</span>
</code></pre></div><p>exception:</p>
<ul>
<li>The first line: 2, dp[i][0] = dp[i - 1][0] + triangle[i][0];</li>
<li>The hypotenuse: 2-&gt; 4 -&gt; 7 -&gt; 3 dp[i][j] = dp[i - 1][j -1] + triangle[i][j];</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">triangle</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">1</span><span class="o">).</span><span class="na">size</span><span class="o">();</span>

    <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">];</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="n">j</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">]).</span><span class="na">min</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>

</code></pre></div><p><strong>method bottom to top</strong></p>
<ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]:  from bottom to [0, 0], the minimum path sum;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>dp[i][j] = min(dp[i + 1][j -1], dp[i + 1][j]) + c[i][j];</p>
<ul>
<li>
<p><em><strong>sp3. initial values</strong></em></p>
</li>
<li>
<p><em><strong>sp4. literacy directions</strong></em></p>
</li>
</ul>
<p>3 directions</p>
<p>down to up</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="n">2</span>                
       <span class="n">3</span>   <span class="n">4</span>             
       <span class="n">6</span>   <span class="n">5</span>   <span class="n">7</span>         
       <span class="n">4</span>   <span class="n">1</span>   <span class="n">8</span>   <span class="n">3</span>                              
</code></pre></div><p>dp</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="n">2</span>                
       <span class="n">3</span>   <span class="n">4</span>             
       <span class="n">6</span>   <span class="n">5</span>   <span class="n">7</span>         
       <span class="n">4</span>   <span class="n">1</span>   <span class="n">8</span>   <span class="n">3</span> 
       <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>    <span class="n">0</span>                     
</code></pre></div><p>dp</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="n">2</span>                
       <span class="n">3</span>   <span class="n">4</span>             
       <span class="n">7</span>   <span class="n">6</span>   <span class="n">10</span>         
       <span class="n">4</span>   <span class="n">1</span>   <span class="n">8</span>   <span class="n">3</span> 
       <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>   <span class="n">0</span>    <span class="n">0</span>                     
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="n">2</span>                
       <span class="n">9</span>   <span class="n">10</span>             
       <span class="n">7</span>   <span class="n">6</span>   <span class="n">10</span>         
       <span class="n">4</span>   <span class="n">1</span>   <span class="n">8</span>   <span class="n">3</span> 
    
<span class="err">```</span><span class="n">java</span>
<span class="err">```</span><span class="n">java</span>                        
       <span class="n">11</span>                
       <span class="n">9</span>   <span class="n">10</span>             
       <span class="n">7</span>   <span class="n">6</span>   <span class="n">10</span>         
       <span class="n">4</span>   <span class="n">1</span>   <span class="n">8</span>   <span class="n">3</span>    
<span class="err">```</span><span class="n">java</span>

<span class="nf">if</span> <span class="o">(</span><span class="n">triangle</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

    <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">])+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">];</span>

</code></pre></div><p><strong>reducing space complexity</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">       <span class="n">2</span>                
       <span class="n">3</span>   <span class="n">4</span>             
       <span class="n">6</span>   <span class="n">5</span>   <span class="n">7</span>         
       <span class="n">4</span>   <span class="n">1</span>   <span class="n">8</span>   <span class="n">3</span>                              
</code></pre></div><p>before:</p>
<blockquote>
<p>dp: 0   0   0   0    0 
1.
dp: 4   1   8   3    0
2.
dp: 7   6   10  3    0
3.
dp: 9   10   10  3    0
4.
dp: 11   10   10  3    0</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">
<span class="k">if</span> <span class="o">(</span><span class="n">triangle</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">1</span><span class="o">).</span><span class="na">size</span><span class="o">();</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">column</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">])+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>

</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">row</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">])+</span> <span class="n">triangle</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>

</code></pre></div><h4 id="q35--minimum-falling-path-sum">Q.35:  Minimum Falling Path Sum</h4>
<p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">https://leetcode-cn.com/problems/minimum-falling-path-sum/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an n x n array of integers matrix, <span class="k">return</span> the minimum sum of any falling path through matrix.

A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position <span class="o">(</span>row, col<span class="o">)</span> will be <span class="o">(</span>row + 1, col - 1<span class="o">)</span>, <span class="o">(</span>row + 1, col<span class="o">)</span>, or <span class="o">(</span>row + 1, col + 1<span class="o">)</span>.

</code></pre></div><p><strong>method top to bottom</strong></p>
<ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>dp[i][j]:  from top to [i, j], the minimum path sum;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>dp[i][j] = min(dp[i - 1][j -1], dp[i - 1][j]) + c[i][j];</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<p>dp[0][0] = c[i][j]</p>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<p>up  to down</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">   

                        <span class="n">dp</span>
       <span class="n">2</span>                <span class="n">2</span>
       <span class="n">3</span>   <span class="n">4</span>            <span class="n">5</span>
       <span class="n">6</span>   <span class="n">5</span>   <span class="n">7</span>        <span class="n">10</span>
       <span class="n">4</span>   <span class="n">1</span>   <span class="n">8</span>   <span class="n">3</span>    <span class="n">11</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">2</span><span class="o">];</span>
<span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">last</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">]))</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
  
<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span>  <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">min</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">min</span><span class="o">;</span>

</code></pre></div><h4 id="q36---count-all-possible-routes">Q.36:   Count All Possible Routes</h4>
<p><a href="https://leetcode-cn.com/problems/count-all-possible-routes/">https://leetcode-cn.com/problems/count-all-possible-routes/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are given an array of distinct positive integers locations where locations<span class="o">[</span>i<span class="o">]</span> represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.

At each step, <span class="k">if</span> you are at city i, you can pick any city j such that j !<span class="o">=</span> i and <span class="m">0</span> &lt;<span class="o">=</span> j &lt; locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by <span class="p">|</span>locations<span class="o">[</span>i<span class="o">]</span> - locations<span class="o">[</span>j<span class="o">]</span><span class="p">|</span>. Please notice that <span class="p">|</span>x<span class="p">|</span> denotes the absolute value of x.

Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once <span class="o">(</span>including start and finish<span class="o">)</span>.

Return the count of all possible routes from start to finish. Since the answer may be too large, <span class="k">return</span> it modulo <span class="m">109</span> + 7.
</code></pre></div><p><strong>memory search DFS</strong></p>
<p><strong>cache[i][j]</strong>
cache[i][j]: start form i, before running out of fuel, the path number to reach the target;</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">1000000007</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">countRoutes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ls</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fuel</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        
        <span class="c1">// initiation
</span><span class="c1"></span>
        <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">fuel</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">cache</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="n">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dfs</span><span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">fuel</span><span class="o">);</span>
    <span class="o">}</span>

<span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ls</span><span class="o">,</span> <span class="kt">int</span> <span class="n">u</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fuel</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// if cache alread has the answer, return
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
         <span class="c1">// base case 1：if the fuel is 0,
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">fuel</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span> 

        <span class="c1">// base case 2
</span><span class="c1"></span>        <span class="kt">boolean</span> <span class="n">hasNext</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">need</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">ls</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">-</span> <span class="n">ls</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>    
                <span class="k">if</span> <span class="o">(</span><span class="n">fuel</span> <span class="o">&gt;=</span> <span class="n">need</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">hasNext</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fuel</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hasNext</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">a</span><span class="o">=</span> <span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">==</span><span class="n">end</span><span class="o">?</span><span class="n">1</span><span class="o">:</span><span class="n">0</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">u</span> <span class="o">==</span> <span class="n">end</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">need</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">ls</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">ls</span><span class="o">[</span><span class="n">u</span><span class="o">]);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">fuel</span> <span class="o">&gt;=</span> <span class="n">need</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">fuel</span> <span class="o">-</span> <span class="n">need</span><span class="o">);</span>
                    <span class="n">sum</span> <span class="o">%=</span> <span class="n">mod</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">]</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
        
</code></pre></div><p>think about basecase</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">1000000007</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">countRoutes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ls</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fuel</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        
        <span class="c1">// initiation
</span><span class="c1"></span>
        <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">fuel</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">cache</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="n">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dfs</span><span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">fuel</span><span class="o">);</span>
    <span class="o">}</span>

<span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ls</span><span class="o">,</span> <span class="kt">int</span> <span class="n">u</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fuel</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// if cache alread has the answer, return
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">need</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">ls</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">-</span> <span class="n">ls</span><span class="o">[</span><span class="n">end</span><span class="o">]);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">need</span> <span class="o">&gt;</span> <span class="n">fuel</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">u</span> <span class="o">==</span> <span class="n">end</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">need</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">ls</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">ls</span><span class="o">[</span><span class="n">u</span><span class="o">]);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">fuel</span> <span class="o">&gt;=</span> <span class="n">need</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">fuel</span> <span class="o">-</span> <span class="n">need</span><span class="o">);</span>
                    <span class="n">sum</span> <span class="o">%=</span> <span class="n">mod</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">cache</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">fuel</span><span class="o">]</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
        
</code></pre></div><p><strong>from memory search DFS to DP</strong></p>
<blockquote>
<p>int dfs(int[] ls, int u, int end, int fuel) {</p>
</blockquote>
<p>changable: U and Fuel</p>
<p>dp[i][fuel] = dp[i][fuel] + f[k][fuel - need]</p>
<p>k is the next stop  of location i , need is the amount fuel needed from i- k;</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">1000000007</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">countRoutes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ls</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fuel</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">fuel</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>

        <span class="c1">// start = end
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">fuel</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">end</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">cur</span> <span class="o">&lt;=</span> <span class="n">fuel</span><span class="o">;</span> <span class="n">cur</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                        <span class="kt">int</span> <span class="n">need</span> <span class="o">=</span>  <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">ls</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">ls</span><span class="o">[</span><span class="n">u</span><span class="o">]);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="n">need</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">cur</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">cur</span> <span class="o">-</span> <span class="n">need</span><span class="o">];</span>
                            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">cur</span><span class="o">]</span> <span class="o">%=</span> <span class="n">mod</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">start</span><span class="o">][</span><span class="n">fuel</span><span class="o">];</span>
    <span class="o">}</span>
        
</code></pre></div><h4 id="q37--minimum-falling-path-sum-ii">Q.37:  Minimum Falling Path Sum II</h4>
<p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/">https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Given an n x n integer matrix grid, <span class="k">return</span> the minimum sum of a falling path with non-zero shifts.

A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.
</code></pre></div><p><strong>method top to bottom</strong></p>
<ul>
<li><em><strong>sp1. dp table and index meaning</strong></em></li>
</ul>
<p>i1: smallest value index
i2: the second smallest value index</p>
<p>dp[i][j] = dp[i - 1][i1] + val;</p>
<ul>
<li><em><strong>sp2. recurrence formula</strong></em></li>
</ul>
<p>dp[i][j] = (dp[i - 1][i1] || dp[i - 1][j]) + c[i][j];</p>
<ul>
<li><em><strong>sp3. initial values</strong></em></li>
</ul>
<p>dp[0][i] = c[0][i]</p>
<ul>
<li><em><strong>sp4. literacy directions</strong></em></li>
</ul>
<p>3 directions</p>
<p>up  to down</p>
<ul>
<li><em><strong>sp5. cases</strong></em></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">                        
       <span class="n">1</span>    <span class="n">2</span>   <span class="n">3</span>
       <span class="n">4</span>    <span class="n">5</span>   <span class="n">6</span>
       <span class="n">7</span>    <span class="n">8</span>   <span class="n">9</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">                        
<span class="n">i</span> <span class="o">-</span> <span class="n">1</span>               <span class="n">i1</span>          <span class="n">i2</span>
      
<span class="n">i</span>           <span class="n">i1</span>  <span class="n">i1</span>  <span class="n">i2</span>  <span class="n">i1</span>  <span class="n">i1</span>  <span class="n">i1</span>  <span class="n">i1</span> <span class="n">i1</span>
</code></pre></div><p>//https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</p></div>
    <div class="post-footer">
        <div class="info">
            
            <span class="separator"><a class="tag" href="/tags/java/">java</a><a class="tag" href="/tags/java-interview/">java interview</a><a class="tag" href="/tags/algorithm/">algorithm</a><a class="tag" href="/tags/dynamic-programming/">Dynamic Programming</a></span>
        </div>
    </div>

    
</div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js"
        integrity="sha256-g8sd1f6o1C2H0eYBoH&#43;qcwia0O&#43;cz&#43;Xa9gQSievMTkY="
        crossorigin="anonymous"></script>
<script async defer src="//latest.js"></script>
<noscript><img src="//noscript.gif" alt=""/></noscript>

</body>

</html>
